<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chenzhongyao.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="chenzhongyao&#39;s website">
<meta property="og:url" content="https://chenzhongyao.github.io/index.html">
<meta property="og:site_name" content="chenzhongyao&#39;s website">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="chennan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chenzhongyao.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>chenzhongyao's website</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">chenzhongyao's website</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/18/images/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/images/" class="post-title-link" itemprop="url">images</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-18 22:39:00 / 修改时间：22:50:32" itemprop="dateCreated datePublished" datetime="2020-06-18T22:39:00+08:00">2020-06-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="四张图彻底搞懂CNN反向传播算法"><a href="#四张图彻底搞懂CNN反向传播算法" class="headerlink" title="四张图彻底搞懂CNN反向传播算法"></a>四张图彻底搞懂CNN反向传播算法</h1><p>阅读本文之前，请首先阅读之前讲述的全连接层的反向传播算法详细推导过程： <a href="https://zhuanlan.zhihu.com/p/79657669" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79657669</a><br>已经了解反向传播算法请自动忽略。</p>
<h2 id="1-卷积层的反向传播"><a href="#1-卷积层的反向传播" class="headerlink" title="1. 卷积层的反向传播"></a>1. 卷积层的反向传播</h2><p>直接上图：<br><img src="images/cnn.png" alt><br>假设输入为一张单通道图像$x$，卷积核大小为$2\times 2$，输出为$y$。为了加速计算，首先将$x$按卷积核滑动顺序依次展开，如上图所示。其中，$\hat{x}$中的红色框代表$x$中的红色框展开后的结果，将$x$依次按照此方式展开，可得$\hat{x}$。同理可得$\hat{w}$，然后通过矩阵相乘可得输出$\hat{y}$（$\hat{y}$与$y$等价）。此时，已经将CNN转化为FC，反向传播算法与<a href="https://zhuanlan.zhihu.com/p/79657669" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79657669</a> 完全一致，这里不再做详细介绍。当输入图像有N个样本时，应该怎么算呢？</p>
<p>当有$N$个样本，即batch=N时，前向与反向传播方式如下图所示：<br><img src="images/cnn-batch.png" alt><br>其中，输入图像batch=3,使用2个$2\times 2\times 3$的卷积核，输出两张图像，如图所示。红色框、黄色框代表的是卷积核以及使用该卷积核得到的输出图像$y$。当输入图像为一个batch时，$x、w$的转化方式如上图，首先将输入图像与卷积核分别按单通道图像展开，然后将展开后的矩阵在行方向级联。此时，已经将CNN转化为了FC，反向传播算法与<a href="https://zhuanlan.zhihu.com/p/79657669" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79657669</a> 完全一致，这里不再做过多介绍。</p>
<h2 id="2-Average-pooling的反向传播"><a href="#2-Average-pooling的反向传播" class="headerlink" title="2. Average pooling的反向传播"></a>2. Average pooling的反向传播</h2><p><img src="images/average-pooling.png" alt><br>$\frac{\partial J}{\partial w}$不用求，因为$w$为常数。$\frac{\partial J}{\partial x<em>{ij}}=\Sigma \frac{\partial J}{\partial \hat{x}</em>{ij}}$</p>
<h2 id="3-Max-pooling的反向传播"><a href="#3-Max-pooling的反向传播" class="headerlink" title="3. Max-pooling的反向传播"></a>3. Max-pooling的反向传播</h2><p><img src="images/max-pooling.png" alt><br>遍历$\hat{x}$的每一行，找出此行最大值的索引$(i,j)$，然后将$\frac{\partial J}{\partial \hat{x}}$中索引为$(i,j)$的值设为$\frac{\partial J}{\partial \hat{y}}$对应行的值，将此行其余列的值设为0，如上图所示红框所示。假设$\hat{x}$中(1,1)处的值是第一行中最大的值，则将$\frac{\partial J}{\partial y<em>{11}}$赋值给$\frac{\partial J}{\partial \hat{x}}$中索引为$(1,1)$的位置。最后计算:$\frac{\partial J}{\partial x</em>{ij}}=\Sigma \frac{\partial J}{\partial \hat{x}_{ij}}$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/18/CNN%E7%9A%84%E5%89%8D%E5%90%91%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/CNN%E7%9A%84%E5%89%8D%E5%90%91%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/" class="post-title-link" itemprop="url">CNN的前向与反向传播</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 21:41:37" itemprop="dateCreated datePublished" datetime="2020-06-18T21:41:37+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-08 14:28:34" itemprop="dateModified" datetime="2019-09-08T14:28:34+08:00">2019-09-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="四张图彻底搞懂CNN反向传播算法"><a href="#四张图彻底搞懂CNN反向传播算法" class="headerlink" title="四张图彻底搞懂CNN反向传播算法"></a>四张图彻底搞懂CNN反向传播算法</h1><p>阅读本文之前，请首先阅读之前讲述的全连接层的反向传播算法详细推导过程： <a href="https://zhuanlan.zhihu.com/p/79657669" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79657669</a><br>已经了解反向传播算法请自动忽略。</p>
<h2 id="1-卷积层的反向传播"><a href="#1-卷积层的反向传播" class="headerlink" title="1. 卷积层的反向传播"></a>1. 卷积层的反向传播</h2><p>直接上图：<br><img src="./images/cnn.png" alt><br>假设输入为一张单通道图像$x$，卷积核大小为$2\times 2$，输出为$y$。为了加速计算，首先将$x$按卷积核滑动顺序依次展开，如上图所示。其中，$\hat{x}$中的红色框代表$x$中的红色框展开后的结果，将$x$依次按照此方式展开，可得$\hat{x}$。同理可得$\hat{w}$，然后通过矩阵相乘可得输出$\hat{y}$（$\hat{y}$与$y$等价）。此时，已经将CNN转化为FC，反向传播算法与<a href="https://zhuanlan.zhihu.com/p/79657669" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79657669</a> 完全一致，这里不再做详细介绍。当输入图像有N个样本时，应该怎么算呢？</p>
<p>当有$N$个样本，即batch=N时，前向与反向传播方式如下图所示：<br><img src="./images/cnn-batch.png" alt><br>其中，输入图像batch=3,使用2个$2\times 2\times 3$的卷积核，输出两张图像，如图所示。红色框、黄色框代表的是卷积核以及使用该卷积核得到的输出图像$y$。当输入图像为一个batch时，$x、w$的转化方式如上图，首先将输入图像与卷积核分别按单通道图像展开，然后将展开后的矩阵在行方向级联。此时，已经将CNN转化为了FC，反向传播算法与<a href="https://zhuanlan.zhihu.com/p/79657669" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79657669</a> 完全一致，这里不再做过多介绍。</p>
<h2 id="2-Average-pooling的反向传播"><a href="#2-Average-pooling的反向传播" class="headerlink" title="2. Average pooling的反向传播"></a>2. Average pooling的反向传播</h2><p><img src="./images/average-pooling.png" alt><br>$\frac{\partial J}{\partial w}$不用求，因为$w$为常数。$\frac{\partial J}{\partial x<em>{ij}}=\Sigma \frac{\partial J}{\partial \hat{x}</em>{ij}}$</p>
<h2 id="3-Max-pooling的反向传播"><a href="#3-Max-pooling的反向传播" class="headerlink" title="3. Max-pooling的反向传播"></a>3. Max-pooling的反向传播</h2><p><img src="./images/max-pooling.png" alt><br>遍历$\hat{x}$的每一行，找出此行最大值的索引$(i,j)$，然后将$\frac{\partial J}{\partial \hat{x}}$中索引为$(i,j)$的值设为$\frac{\partial J}{\partial \hat{y}}$对应行的值，将此行其余列的值设为0，如上图所示红框所示。假设$\hat{x}$中(1,1)处的值是第一行中最大的值，则将$\frac{\partial J}{\partial y<em>{11}}$赋值给$\frac{\partial J}{\partial \hat{x}}$中索引为$(1,1)$的位置。最后计算:$\frac{\partial J}{\partial x</em>{ij}}=\Sigma \frac{\partial J}{\partial \hat{x}_{ij}}$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96/" class="post-title-link" itemprop="url">深度学习中的正则化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 21:41:36" itemprop="dateCreated datePublished" datetime="2020-06-18T21:41:36+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-29 23:12:26" itemprop="dateModified" datetime="2019-08-29T23:12:26+08:00">2019-08-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深度学习中的正则化"><a href="#深度学习中的正则化" class="headerlink" title="深度学习中的正则化"></a>深度学习中的正则化</h1><p>正则化的定义为”对学习算法的修改—旨在减少泛化误差而非训练误差”。正则化的策略包括参数范数惩罚、约束范数惩罚、提前终止以及Dropout等等。</p>
<h3 id="一、参数范数惩罚"><a href="#一、参数范数惩罚" class="headerlink" title="一、参数范数惩罚"></a><strong>一、参数范数惩罚</strong></h3><p>参数惩罚是指在目标函数$J$中添加一个参数范数惩罚$\Omega(\theta)$,限制模型的学习能力：</p>
<script type="math/tex; mode=display">\tilde{J}(\theta;X, y)=J(\theta; X, y)+\alpha\Omega(\theta)</script><p>当我们的算法最小化正则化后的目标函数$\tilde{J}$时，它会降低原始目标$J$关于训练数据的误差并同时减少在某些衡量标注下参数$\theta$的规模。选择不同的参数范数$\Omega$会偏好不同的解。<br>参数范数惩罚通常只惩罚权重$W$，不管b。因为(1)精确拟合偏置所需的数据比拟合权重少的多，每个权重会指定两个变量如何相互作用，我们需要在各种条件下观察这两个变量才能良好地拟合权重，而每个偏置只控制一个单变量。这意味着我们不对其进行正则化也不会导致太大的方差。(2)正则化偏置参数可能会导致明显的欠拟合。基于以上两点，我们通常指惩罚权重$W$，即$\theta =(W;b)\approx (W)$。</p>
<h4 id="1-L2参数正则化-Omega-theta-frac-1-2-w-2"><a href="#1-L2参数正则化-Omega-theta-frac-1-2-w-2" class="headerlink" title="1. L2参数正则化: $\Omega(\theta)=\frac{1}{2}||w||^2$"></a>1. L2参数正则化: $\Omega(\theta)=\frac{1}{2}||w||^2$</h4><p>目标函数：</p>
<script type="math/tex; mode=display">\tilde{J}(w;X,y)=J(w;X,y)+\frac{\alpha}{2}w^Tw</script><p>计算梯度：</p>
<script type="math/tex; mode=display">\bigtriangledown _w\tilde{J}(w;X,y)=\bigtriangledown_wJ(w;X,y)+\alpha w</script><p>更新权重：</p>
<script type="math/tex; mode=display">w\leftarrow w-\eta(\alpha w+\bigtriangledown_wJ(w;X,y))=(1-\eta \alpha)w-\eta \bigtriangledown_wJ(w;X,y)</script><p>从上式可以看出，加入权重衰减后会导致学习规则的修改，即在每步执行梯度更新前先收缩权重（乘以($1-\eta \alpha$)）</p>
<h4 id="2-L1参数正则化：-Omega-theta-w-1-Sigma-i-w-i"><a href="#2-L1参数正则化：-Omega-theta-w-1-Sigma-i-w-i" class="headerlink" title="2. L1参数正则化：$\Omega(\theta)=||w||_1=\Sigma_i|w_i|$"></a>2. L1参数正则化：$\Omega(\theta)=||w||_1=\Sigma_i|w_i|$</h4><p>目标函数：</p>
<script type="math/tex; mode=display">\tilde{J}(w;X,y)=J(w;X,y)+\alpha||w||_1</script><p>计算梯度：</p>
<script type="math/tex; mode=display">\bigtriangledown _w\tilde{J}(w;X,y)=\bigtriangledown_wJ(w;X,y)+\alpha sign(w)</script><p>其中，$sign(w)=\left{\begin{matrix}<br>-1 ,&amp; w&lt; 0\<br> 1,&amp; w&gt;0<br>\end{matrix}\right.$</p>
<p>更新权重：</p>
<script type="math/tex; mode=display">w\leftarrow w-\eta(\alpha sign(w)+\bigtriangledown_wJ(w;X,y))</script><h3 id="二、约束范数惩罚"><a href="#二、约束范数惩罚" class="headerlink" title="二、约束范数惩罚"></a><strong>二、约束范数惩罚</strong></h3><p>约束惩罚是指向目标函数中增加额外项来对参数值进行软约束：</p>
<script type="math/tex; mode=display">\left \{ \begin{matrix}
    minJ(\theta) \\ s.t. \quad \Omega(\theta)\leq k
\end{matrix}\right.</script><p>构造拉格朗日函数：</p>
<script type="math/tex; mode=display">L(\theta, \alpha)=J(\theta)+\alpha(\Omega(\theta)-k)</script><p>原始问题等价于：</p>
<script type="math/tex; mode=display">\theta^*=\argmin_\theta \max_{\alpha;\alpha\geq 0}L(\theta, \alpha)</script><p>为了洞察约束的影响，我们可以固定$\alpha^*$，把这个问题看成只跟$\theta$有关的函数：</p>
<script type="math/tex; mode=display">\theta^*=\argmin_\theta L(\theta, \alpha^*)=\argmin_\theta J(\theta;X,y)+\alpha^*\Omega(\theta)</script><p>这和最小化$\tilde{J}$的正则化训练问题是完全一样的。因此，我们可以把参数范数惩罚看做对权重强加的约束。如果$\Omega$是$L^2$范数，那么权重就是被约束在一个$L^2$球中，如果$\Omega$是$L^1$范数，那么权重就是被约束在一个$L^1$范数限制的区域中。</p>
<h3 id="三、提前终止"><a href="#三、提前终止" class="headerlink" title="三、提前终止"></a><strong>三、提前终止</strong></h3><p>当训练有足够的表示能力甚至会过拟合的大模型时，我们经常观察到，训练误差会随着时间的推移逐渐降低，蛋验证集的误差会再次上升。这意味着我们只要返回使验证集误差最低的参数设置，就可以获得验证集误差更低的模型（并且因此有希望获得更好的测试误差）。</p>
<p>提前终止需要验证集，这意味着某些训练数据不能被馈送到模型。为了更好地利用这一额外的数据，我们可以在完成提前终止的首次训练之后，进行额外的训练。在第二轮，即额外的训练步骤中，所有的训练数据都被包括在内。有两个基本的策略都可以用于第二轮训练过程：</p>
<ul>
<li><strong>一是再次初始化模型，然后使用所有数据再次训练。</strong> 在这个第二轮训练过程中，我们使用第一轮提前终止训练确定的最佳步数。但是有一个问题是，我们没有办法知道重新训练时，对参数进行相同次数的更新和对数据集进行相同次数的遍历哪一个更好。由于训练集变大了，在第二次训练时，每一次遍历数据集将会更多次地更新参数。</li>
<li><strong>二是保持从第一轮训练获得的参数，然后使用全部的数据继续训练。</strong> 在这个阶段，已经没有验证集指导我们需要再训练多少步后终止，取而代之，我们可以监控验证集的平均损失函数，并继续训练，直到它低于提前终止过程终止时的目标值。此策略避免了重新训练模型的高成本，但表现并没有那么好，例如，验证集的目标不一定能达到之前的目标值，所以这种策略甚至不能保证终止。<h3 id="四、-噪声鲁棒性"><a href="#四、-噪声鲁棒性" class="headerlink" title="四、 噪声鲁棒性"></a><strong>四、 噪声鲁棒性</strong></h3>大多数数据集的y标签都有一定的错误性。错误的y不利于最大化$\log p(y|x)$。为避免这种情况发生，一种方法是显示地对标签上的噪声进行建模。</li>
</ul>
<p>例如，我们可以假设，对于一些小常数$\epsilon$,训练集标记$y$是正确的概率为$1-\epsilon$，(以$\epsilon$的概率）任何其他可能的标签也可能是正确的。这个假设很容易就能解析地狱代价函数结合，而不用显式地抽取噪声样本。例如，标签平滑（label smoothing）通过把确切分类目标从0和1替换成$\frac{\epsilon}{K-1}$和$1-\epsilon$,正则化具有$K$个输出的softmax函数的模型。标准交叉熵可以用在这些非确切目标的输出上。使用<strong>softmax和明确目标的最大似然学习可能永远不会收敛—softmax函数永远无法真正预测0概率和1概率，因此他会继续学习越来越大的权重，使预测更极端</strong>。标签平滑的优势是能够防止模型追求确切概率而不影响模型学习正确分类。</p>
<h3 id="五、半监督学习"><a href="#五、半监督学习" class="headerlink" title="五、半监督学习"></a><strong>五、半监督学习</strong></h3><p>假设有100张$10\times 10$的图片，其中50张有标签（共5类），50张无标签。如果利用普通的神经网络训练时只能够用到50张有标签的图片，而另外50张无标签图像无法使用。</p>
<p>半监督学习的做法是：</p>
<ul>
<li>首先将100维的图像利用PCA降维到30维。</li>
<li>利用共享权重的神经网络，有标签的50张图像将标签作为label，无标签的图像将PCA降维后的低维度作为label，如下图所示<br><img src="./images/半监督学习.png" alt><h3 id="六、多任务学习"><a href="#六、多任务学习" class="headerlink" title="六、多任务学习"></a><strong>六、多任务学习</strong></h3>多任务学习是通过合并几个任务中的样例（可以视为对参数施加的软约束）来提高泛化的一种方式。当模型的一部分被多个额外的任务共享时，这部分将被约束为良好的值，通常会带来更好的泛化能力。下图表示了多任务学习的一种普遍形式。不同的监督任务共享相同的输入x和中间层，能学习共同的因素池。从深度学习的观点看，底层的先验知识如下：能解释数据变化（在与之相关联的不同任务中观察到）的因素中，某些因素是夸两个或多个任务共享的，如人脸识别任务与性别分类任务。<br><img src="./images/多任务学习.png" alt><h3 id="七、Bagging及其他集成方法"><a href="#七、Bagging及其他集成方法" class="headerlink" title="七、Bagging及其他集成方法"></a><strong>七、Bagging及其他集成方法</strong></h3>Bagging（bootstrap aggregating）是通过结合几个模型降低泛化误差的技术。主要想法是分别训练几个不同的模型，然后让所有模型表决测试样例的输出。这机器学习中常规策略的一个例子，被称为模型平均（model averaging）。采用这种策略的技术被称为集成方法。</li>
</ul>
<p>我们假设有k个回归模型，每个模型在每个例子上的误差是$\epsilon_i$，误差服从均值为0、方差为$\mathbb{E}[\epsilon_i^2]=v$、协方差为$\mathbb{E}[\epsilon_i\epsilon_j]=c$的多维正态分布。通过所有集成模型的平均预测误差为：$\frac{1}{k}\Sigma_i\epsilon_i$。集成预测器平方误差的期望是：</p>
<script type="math/tex; mode=display">\mathbb{E}[(\frac{1}{k}\sum_i\epsilon_i)^2]=\frac{1}{k^2}\mathbb{E}[\sum_i(\epsilon_i^2+\sum_{j\neq i}\epsilon_i\epsilon_j)]=\frac{1}{k}v+\frac{k-1}{k}c</script><p>在误差完全相关即$c=v$的情况下，均方误差减少到$v$，所以模型平均没有任何帮助。在误差完全不相关即$c=0$的情况下，该集成的平方误差的期望仅为$\frac{1}{k}v$。这意味着集成平方误差的期望会随着集成规模增大而线性减少。换言之，平均上，集成至少与它的任何成员表现的一样好，并且如果成员的误差是独立的，集成将显著地比其成员表现得更好。</p>
<p>不同的集成方法以不同的方式构建集成模型。例如，集成的每个成员可以使用不同的算法和目标函数训练成完全不同的模型。Bagging是一种允许重复多次使用同一种模型，训练算法和目标函数的方法。</p>
<blockquote>
<p>参考资料：深度学习</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">深度学习中的模型优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 21:41:36" itemprop="dateCreated datePublished" datetime="2020-06-18T21:41:36+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-04 01:45:25" itemprop="dateModified" datetime="2019-09-04T01:45:25+08:00">2019-09-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深度学习中的模型优化"><a href="#深度学习中的模型优化" class="headerlink" title="深度学习中的模型优化"></a>深度学习中的模型优化</h1><h2 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h2><h3 id="Batch-Gradient-Descent-BGD"><a href="#Batch-Gradient-Descent-BGD" class="headerlink" title="Batch Gradient Descent(BGD)"></a>Batch Gradient Descent(BGD)</h3><p>BGD在训练中,每一步迭代都是用训练集中的所有数据,也就是说,利用现有参数对训练集中的每一个输入生成一个估计输出,然后跟实际输出比较,统计所有误差,求平均以后得到平均误差,并以此作为更新参数的依据.</p>
<ul>
<li><strong>优点:</strong> 由于每一步都利用了训练集中的所有数据,因此当损失函数达到最小值以后,能够保证此时计算出的梯度为0,换句话说,就是能够收敛(曲线比较平滑),因此,使用BGD时不需要逐渐降低学习率.</li>
<li><strong>缺点:</strong> 由于每一步都要用到所有训练数据,因此随着数据集的增大,运行速度会越来越慢.<h3 id="SGD与MBGD"><a href="#SGD与MBGD" class="headerlink" title="SGD与MBGD"></a>SGD与MBGD</h3>MBGD是指在训练中,每次使用小批量(一个小批量训练m个样本)的随机采样进行梯度下降.训练方法与BGD一样,只是BGD最后对训练集的所有样本取平均,而MBGD只对小批量的m个样本取平均.SGD是指在训练中每次仅使用一个样本.MBGD与SGD统称为SGD.因为小批量不能代表整个训练集,使得梯度估计引入噪声源,因此SGD并不是每次迭代都向着整体最优化方向.虽然SGD包含一定的随机性(表现为损失函数的震荡),但是从期望来看,它是等于正确的导数的(表现为损失函数有减小的趋势).</li>
<li><strong>优点:</strong> 训练速度比较快</li>
<li><strong>缺点:</strong> 在样本数量较大的情况下,可能只用到了其中一部分数据就完成了训练,得到的只是局部最优解.另外,小批量样本的噪声较大,所以每次执行梯度下降,并不一定总是朝着最优的方向前进.<br><img src="./images/SGD与BGD.png" alt><h3 id="参数更新"><a href="#参数更新" class="headerlink" title="参数更新"></a>参数更新</h3><script type="math/tex; mode=display">\left \{
\begin{array}{l}{\boldsymbol{v}_{t}=-\eta \triangledown_\theta J\left(\boldsymbol{\theta}_{t}\right) } \\ {\boldsymbol{\theta}_{t} =\boldsymbol{\theta}_{t-1}+\boldsymbol{v}_{t}}\end{array} \right.</script>其中，$\eta$代表学习率，$\theta<em>t$表示$t$时刻的参数，$\triangledown </em>\theta J(\theta_t)$代表参数$\theta$在$t$时刻的导数，$v_t$代表参数的更新速度。<h2 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h2>在训练中，采取的策略与SGD一样，不同的是学习率的更新方式。动量的参数更新方式为：<script type="math/tex; mode=display">\left \{
\begin{array}{l}{\boldsymbol{v}_{t}=-\eta \triangledown_\theta J\left(\boldsymbol{\theta}_{t}\right)+\alpha \boldsymbol{v}_{t-1}} \\ {\boldsymbol{\theta}_{t+1} =\boldsymbol{\theta}_{t}+\boldsymbol{v}_{t}}\end{array} \right.</script>$\alpha$一般取值0.9.</li>
</ul>
<p>直观理解为：<br><img src="./images/momentum.jpg" alt><br>动量方法旨在加速学习（加快梯度的下降速度），特别是处理高曲率、小但一致的梯度，或是带噪声的梯度。动量算法累积了之前梯度指数级衰减的移动平均，并且继续沿该方向移动。</p>
<table align="center">
    <tr>
        <td><center><img height="200" width="300" src="./images/momentum.gif"></center></td>
    </tr>
</table>

<p>动量SGD算法引入$\alpha \boldsymbol{v}_{t-1}$使每一次的参数更新方向不仅仅取决于当前位置的梯度，还受到上一次参数更新方向的影响（如上图所示）。在某一维度上，当梯度方向不变时，更新速度变快，当梯度方向有所改变时，更新速度变慢，从而加快收敛速度，减少震荡。</p>
<p>带有动量的SGD的优点：</p>
<ul>
<li>加快收敛速度</li>
<li>抑制梯度下降时上下震荡的情况</li>
<li>通过局部极小点</li>
</ul>
<blockquote>
<p>分析：假设任意时刻参数的梯度均为$g<em>t=\triangledown</em>\theta J\left(\boldsymbol{\theta}_{t}\right)=g_0$，则使用SGD时,$t$时刻的梯度$g^{SGD}_t=g_0$,Momentum算法的梯度$g^{mom}_t=(\alpha^{t-1}+\alpha^{t-2}+…+\alpha+1)g_0=\frac{1-\alpha^{t}}{1-\alpha}g_0$.当$t\rightarrow +\infty$，因$\alpha&lt;1$,所以$\alpha^t\rightarrow 0$,所以$g_t^{mom}\rightarrow \frac{1}{1-\alpha}g_0$,当$\alpha=0.9$时，Momentum更新速度是SGD的10倍</p>
</blockquote>
<h2 id="Nesterov-NAG"><a href="#Nesterov-NAG" class="headerlink" title="Nesterov(NAG)"></a>Nesterov(NAG)</h2><p>Nesterov动量是Momentum的变种，即在计算参数梯度之前，前瞻一步，超前一个动量单位处：$\theta<em>t + \gamma v</em>{t-1}$,Nesterov动量可以理解为往Momentum动量中加入了一个校正因子。参数更新公式为：</p>
<script type="math/tex; mode=display">\left \{
\begin{array}{l}{\boldsymbol{v}_{t}=-\eta \triangledown_\theta J\left(\boldsymbol{\theta}_{t}+\gamma \boldsymbol{v}_{t-1}\right)+\alpha \boldsymbol{v}_{t-1}} \\ {\boldsymbol{\theta}_{t+1} =\boldsymbol{\theta}_{t}+\boldsymbol{v}_{t}}\end{array} \right.</script><p>Momentum动量与Nesterov动量的对比如下图所示，其中$\eta \triangledown<em>1$代表A节点 ($\theta_t$)的梯度，$\eta \triangledown_2$代表B节点($\theta</em>{t}+\gamma \boldsymbol{v}<em>{t-1}$的梯度)，灰色实线代表$t-1$时刻的速度$\alpha v</em>{t-1}$.</p>
<table align="center">
    <tr>
        <td><center><img height="230" width="250" src="./images/nesterov.png"></center></td>
        <td><center><img height="230" width="300" src="./images/nesterov.bmp"></center></td>
    </tr>
</table>

<blockquote>
<p>注意：图中的$\eta \triangledown_1以及\eta \triangledown_2$应该为$-\eta \triangledown_1$、$-\eta \triangledown_2$因为梯度方向是增长速度最快的方向，而图中所示为梯度的反方向，所以应该为$-\eta \triangledown_1$、$-\eta \triangledown_2$.</p>
</blockquote>
<p>Nesterov动量相对于Momentum多了一个本次梯度相对上次梯度的变化量，这个变化量本质上是对目标函数二阶导的近似，由于令了二阶导的信息，Nesterov动量算法才会比Momentum具有更快的收敛速度。</p>
<h2 id="AdaGrad"><a href="#AdaGrad" class="headerlink" title="AdaGrad"></a>AdaGrad</h2><p>AdaGrad其实是对学习率进行了约束，AdaGrad独立地适应所有模型参数的学习率，缩放每个参数反比于其它所有梯度历史平方值总和的平方根。损失较大偏导的参数相应地拥有一个快速下降的学习率，而较小偏导的参数在学习率上有相对较小的下降。净效果是在参数空间中更为平缓的倾斜方向会取得更大的进步。参数更新公式为：</p>
<script type="math/tex; mode=display">\left \{
\begin{array}{l}{
    g_t=\triangledown_\theta J(\theta_t)}\\
    {n_t=n_{t-1}+g_t^2} \\
    {\boldsymbol{v}_{t}=-\frac{\eta}{\sqrt{n_t+\epsilon}}g_t } \\ {\boldsymbol{\theta}_{t+1} =\boldsymbol{\theta}_{t}+\boldsymbol{v}_{t}}\end{array} \right.</script><p>其中，$\epsilon$是个很小的数，用来保证分母非0。对$𝑔_𝑡$从1到t进行一个递推形成一个约束项regularizer——-$\frac{1}{\sqrt{n_t+\epsilon}}$。</p>
<p><strong>优点：</strong><br>前期$g_t$较小的时候， $\frac{1}{\sqrt{n_t+\epsilon}}$较大，梯度更新较大，可以解决SGD中学习率一直不变的问题;后期$g_t$较大的时候，$\frac{1}{\sqrt{n_t+\epsilon}}$较小，能够约束梯度.适合处理稀疏梯度.</p>
<p><strong>缺点：</strong><br>由公式可以看出，AdaGrad依赖于人工设置一个全局学习率𝜂，当$\eta$设置过大时，使regularizer过于敏感，对梯度的调节太大。在中后期，分母上梯度平方的累加将会越来越大，gradient→0，网络的更新能力会越来越弱，学习率会变的极小，使得训练提前结束。为了解决这样的问题，又提出了Adadelta算法。</p>
<h2 id="Adadelta"><a href="#Adadelta" class="headerlink" title="Adadelta"></a>Adadelta</h2><p>Adadelta是对AdaGrad的扩展，AgaGrad会累加所有历史梯度的平方，而Adadelta只累加固定大小的项，并且也不直接存储这些项，仅仅是近似计算对应的平均值。参数更新方式为：</p>
<script type="math/tex; mode=display">\left \{
\begin{array}{l}{
    g_t=\triangledown_\theta J(\theta_t)}\\
    {n_t=\gamma n_{t-1}+(1-\gamma)g_t^2}\\
    {\boldsymbol{v}_{t}=-\frac{\eta}{\sqrt{n_t+\epsilon}}g_t } \\ {\boldsymbol{\theta}_{t+1} =\boldsymbol{\theta}_{t}+\boldsymbol{v}_{t}}\end{array} \right.</script><p>但是，此时Adadelta其实仍然依赖于全局学习率，因此，又做了一些处理，新的参数更新方式为：</p>
<script type="math/tex; mode=display">\left \{
\begin{array}{l}{
    g_t=\triangledown_\theta J(\theta_t)}\\
    {E|g^2|_t=\rho \times E|g^2|_{t-1}+(1-\rho)\times g_t^2}\\
    {v_t=-\frac{\sqrt{\sum_{r=1}^{t-1}}v_r}{\sqrt{E|t^2|_t+\epsilon}}g_t}\\
    {\boldsymbol{\theta}_{t+1} =\boldsymbol{\theta}_{t}+\boldsymbol{v}_{t}}\end{array} \right.</script><p>新的参数更新方式，不依赖于全局学习率，并且，训练初中期，加速效果不错，很快；训练后期，反复在局部最小值附近抖动。</p>
<h2 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h2><p>RMSprop可以算作Adadelta的一个特例：当$\rho=0.5$时，$E|g^2|<em>t=\rho \times E|g^2|</em>{t-1}+(1-\rho)\times g_t^2$就变为了求梯度平方和的平均数。</p>
<p>如果再求根的话，就变成了RMS(均方根)：$RMS|g|_t=\sqrt{E|g^2|_t+\epsilon}$。RMSprop的参数更新方式为：</p>
<script type="math/tex; mode=display">\left \{
\begin{array}{l}{
    g_t=\triangledown_\theta J(\theta_t)}\\
    {E|g^2|_t=\rho \times E|g^2|_{t-1}+(1-\rho)\times g_t^2} \\
    {RMS|g|_t=\sqrt{E|g^2|_t+\epsilon}}\\
    {\boldsymbol{v}_{t}=-\frac{\eta}{RMS|g|_t }g_t} \\ {\boldsymbol{\theta}_{t+1} =\boldsymbol{\theta}_{t}+\boldsymbol{v}_{t}}\end{array} \right.</script><p><strong>特点：</strong> (1)RMSprop依然依赖于全局学习率;(2)RMSprop算是Adagrad的一种发展，和Adadelta的变体，效果趋于二者之间;(3)适合处理非平稳目标 - 对于RNN效果很好</p>
<h2 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h2><p>Adam优化器结合了AdaGrad与RMSProp两种算法的优点。对梯度的一阶距估计$m_t$（即梯度的均值）和二阶距估计$n_t$（即梯度的未中心化的方差）进行综合考虑，计算出更新步长。更新方式为：</p>
<script type="math/tex; mode=display">\left \{
\begin{array}{l}{
    g_t=\triangledown_\theta J(\theta_t)}\\
    {m_t=\beta_1m_{t-1}+(1-\beta_1)g_t}\\
    {v_t=\beta_2v_{t-1}+(1-\beta_2)g_t^2}\\
    {\hat{m_t}=\frac{m_t}{1-\beta_1^t}}\\
    {\hat{v}_t=\frac{v_t}{1-\beta_2^t}}\\
    {\boldsymbol{\theta}_{t+1}=\boldsymbol{\theta}_{t}-\frac{\eta}{\sqrt{\hat{v}_t+\epsilon}}\hat{m}_t}\\
\end{array} \right.</script><blockquote>
<p>注：所有的$t$均表示$t$时刻。$m_t$、$n_t$分别是梯度的一阶距估计和二阶距估计，可以看做是对期望$E|g_t|、E|g_t^2|$的估计；$\hat{m}_t、\hat{n}_t$是对$m_t$、$n_t$的校正，这样可以近似为对期望的无偏估计。</p>
</blockquote>
<p><strong>优点：</strong></p>
<ol>
<li>实现简单，计算高效，对内存需求少</li>
<li>参数的更新不受梯度的伸缩变换影响</li>
<li>超参数具有很好的解释性，且通常无需调整或仅需很少的微调</li>
<li>更新的步长能够被限制在大致的范围内（初始学习率）</li>
<li>能自然地实现步长退火过程（自动调整学习率）</li>
<li>很适合应用于大规模的数据及参数的场景</li>
<li>适用于不稳定目标函数</li>
<li>适用于梯度稀疏或梯度存在很大噪声的问题</li>
</ol>
<blockquote>
<p>参考资料：</p>
<p><a href="https://zhuanlan.zhihu.com/p/73264637" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73264637</a> </p>
<p><a href="https://zhuanlan.zhihu.com/p/60088231" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60088231</a></p>
<p><a href="https://blog.csdn.net/u012759136/article/details/52302426" target="_blank" rel="noopener">https://blog.csdn.net/u012759136/article/details/52302426</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/18/%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E5%88%B7%E8%BF%87%E7%9A%84%E5%89%91%E6%8C%87offer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E5%88%B7%E8%BF%87%E7%9A%84%E5%89%91%E6%8C%87offer/" class="post-title-link" itemprop="url">那些年，刷过的剑指offer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 21:41:36" itemprop="dateCreated datePublished" datetime="2020-06-18T21:41:36+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-24 02:01:51" itemprop="dateModified" datetime="2019-09-24T02:01:51+08:00">2019-09-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-连续子数组的最大和"><a href="#1-连续子数组的最大和" class="headerlink" title="1. 连续子数组的最大和"></a>1. 连续子数组的最大和</h3><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mx = INT_MIN;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty()) <span class="keyword">return</span> mx;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">array</span>.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cur += <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="keyword">if</span>(cur &gt; mx)</span><br><span class="line">                mx = cur;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur &lt;= <span class="number">0</span>)</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-第N个丑数"><a href="#2-第N个丑数" class="headerlink" title="2. 第N个丑数"></a>2. 第N个丑数</h3><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">7</span>) <span class="keyword">return</span> index;    <span class="comment">//小于7时为其本身</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>, p3 = <span class="number">0</span>, p5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minNum = <span class="number">1</span>;</span><br><span class="line">        nums.push_back(minNum);</span><br><span class="line">        <span class="keyword">while</span>(nums.<span class="built_in">size</span>()&lt;index)</span><br><span class="line">        &#123;</span><br><span class="line">            minNum = <span class="built_in">min</span>(nums[p2]*<span class="number">2</span>, <span class="built_in">min</span>(nums[p3]*<span class="number">3</span>, nums[p5]*<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span>(minNum == nums[p2]*<span class="number">2</span>)</span><br><span class="line">                p2++;</span><br><span class="line">            <span class="keyword">if</span>(minNum == nums[p3]*<span class="number">3</span>)</span><br><span class="line">                p3++;</span><br><span class="line">            <span class="keyword">if</span>(minNum == nums[p5]*<span class="number">5</span>)</span><br><span class="line">                p5++;</span><br><span class="line">            nums.push_back(minNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-第一个出现一次的字符"><a href="#3-第一个出现一次的字符" class="headerlink" title="3. 第一个出现一次的字符"></a>3. 第一个出现一次的字符</h3><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">char</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">                mp[str[i]]++;   <span class="comment">//map貌似可以直接这样，不用考虑当key不存在时的情况，应该会默认创建</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[str[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-数组中的逆序对"><a href="#4-数组中的逆序对" class="headerlink" title="4. 数组中的逆序对"></a>4. 数组中的逆序对</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.empty()) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;copy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.<span class="built_in">size</span>();i++)</span><br><span class="line">           copy.push_back(data[i]);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> count = help(data, copy, <span class="number">0</span>, data.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> count % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;data, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;copy, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == <span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            copy[start] = data[start];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (<span class="built_in">end</span> - start) / <span class="number">2</span> + start;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> left = help(copy, data, start, mid);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> right = help(copy, data, mid+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">int</span> i = mid, j = <span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=start &amp;&amp; j&gt;=mid+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i] &gt; data[j])</span><br><span class="line">            &#123;</span><br><span class="line">                copy[index--] = data[i--];</span><br><span class="line">                count += j - (mid + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                copy[index--] = data[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; i&gt;=start; i--)</span><br><span class="line">            copy[index--] = data[i];</span><br><span class="line">        <span class="keyword">for</span>(; j&gt;=mid+<span class="number">1</span>; j--)</span><br><span class="line">            copy[index--] = data[j];</span><br><span class="line">        <span class="keyword">return</span> left + right + count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5-两个链表的公共子节点"><a href="#5-两个链表的公共子节点" class="headerlink" title="5. 两个链表的公共子节点"></a>5. 两个链表的公共子节点</h3><p>输入两个链表，找出它们的第一个公共结点。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span>：首先遍历每个链表求其长度len1, len2，然后使长的链表先走<span class="built_in">abs</span>(len1-len2),之后再一起走，第一个相同的节点就是第一个公共子节点</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead1 || !pHead2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">        ListNode* ptr1 = pHead1, *ptr2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(ptr1)</span><br><span class="line">        &#123;</span><br><span class="line">            len1++;</span><br><span class="line">            ptr1 = ptr1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ptr2)</span><br><span class="line">        &#123;</span><br><span class="line">            len2++;</span><br><span class="line">            ptr2 = ptr2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr1 = pHead1, ptr2 = pHead2;</span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len1-len2; i++)</span><br><span class="line">                ptr1 = ptr1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len2-len1; i++)</span><br><span class="line">                ptr2 = ptr2-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(ptr1!=ptr2)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr1 = ptr1-&gt;next;</span><br><span class="line">            ptr2 = ptr2-&gt;next;</span><br><span class="line">        &#125;a</span><br><span class="line">        <span class="keyword">return</span> ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">方法<span class="number">2</span>：双指针法，两个指针p1, p2分别指向两个链表的头节点pHead1, pHead2，当一个指针p1走到末尾时，使p1接着指向pHead2,当指针p2走到末尾时，使p2接着指向pHead1，直到两者相等。</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead1 || !pHead2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* ptr1 = pHead1, *ptr2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(ptr1 != ptr2)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr1 = ptr1==<span class="literal">NULL</span>?pHead2:ptr1-&gt;next;</span><br><span class="line">            ptr2 = ptr2==<span class="literal">NULL</span>?pHead1:ptr2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-数字在排序数组中出现的次数"><a href="#6-数字在排序数组中出现的次数" class="headerlink" title="6. 数字在排序数组中出现的次数"></a>6. 数字在排序数组中出现的次数</h3><p>统计一个数字在排序数组中出现的次数（二分查找法实现logn）</p>
<p>来自 <a href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&amp;tqId=11190&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&amp;tqId=11190&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = data.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = getFirstKIndex(data, <span class="number">0</span>, len<span class="number">-1</span>, k);</span><br><span class="line">        <span class="keyword">int</span> right = getLastKIndex(data, <span class="number">0</span>, len<span class="number">-1</span>, k);</span><br><span class="line">        <span class="keyword">if</span>(left&gt;<span class="number">-1</span> &amp;&amp; right&gt;<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFirstKIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;data, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; <span class="built_in">end</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (<span class="built_in">end</span> - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data[mid]==k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid==start || data[mid<span class="number">-1</span>] != data[mid])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">end</span> = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data[mid]&gt;k)</span><br><span class="line">            <span class="built_in">end</span> = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getFirstKIndex(data, start, <span class="built_in">end</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLastKIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;data, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;<span class="built_in">end</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (<span class="built_in">end</span> - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data[mid]==k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid == <span class="built_in">end</span> || data[mid+<span class="number">1</span>]!=data[mid])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data[mid]&gt;k)</span><br><span class="line">            <span class="built_in">end</span> = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getLastKIndex(data, start, <span class="built_in">end</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="7-求二叉树的深度"><a href="#7-求二叉树的深度" class="headerlink" title="7. 求二叉树的深度"></a>7. 求二叉树的深度</h3><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&amp;tqId=11191&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&amp;tqId=11191&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lf = TreeDepth(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rg = TreeDepth(pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> lf&gt;rg?lf+<span class="number">1</span>:rg+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="8-平衡二叉树"><a href="#8-平衡二叉树" class="headerlink" title="8. 平衡二叉树"></a>8. 平衡二叉树</h3><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span>：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> lf = TreeHeight(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rg = TreeHeight(pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">bool</span> left = IsBalanced_Solution(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">bool</span> right = IsBalanced_Solution(pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(lf-rg)&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeHeight</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lf = TreeHeight(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rg = TreeHeight(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> lf&gt;rg?lf+<span class="number">1</span>:rg+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">方法<span class="number">2</span>：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> balanced(pRoot, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">balanced</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            depth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lf, rg;</span><br><span class="line">        <span class="keyword">bool</span> left = balanced(root-&gt;left, lf);</span><br><span class="line">        <span class="keyword">bool</span> right = balanced(root-&gt;right, rg);</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right &amp;&amp; <span class="built_in">abs</span>(lf-rg)&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            depth = <span class="built_in">max</span>(lf, rg) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="9-和为S的连续正数序列"><a href="#9-和为S的连续正数序列" class="headerlink" title="9. 和为S的连续正数序列"></a>9. 和为S的连续正数序列</h3><p>题目描述<br>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!<br>输出描述:<br>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
<p>来自 <a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&amp;tqId=11194&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&amp;tqId=11194&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">FindContinuousSequence</span><span class="params">(<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> curSum = left + right;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= sum/<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curSum==sum)</span><br><span class="line">            &#123;</span><br><span class="line">                help(res, left, right);</span><br><span class="line">                right++;</span><br><span class="line">                curSum += right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curSum&gt;sum)</span><br><span class="line">            &#123;</span><br><span class="line">                curSum -= left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curSum&lt;sum)</span><br><span class="line">            &#123;</span><br><span class="line">                right++;</span><br><span class="line">                curSum += right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;=right; i++)</span><br><span class="line">            tmp.push_back(i);</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="10-和为S的两个数字"><a href="#10-和为S的两个数字" class="headerlink" title="10. 和为S的两个数字"></a>10. 和为S的两个数字</h3><p>题目描述:<br>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<p>输出描述:<br>对应每个测试案例，输出两个数，小的先输出。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&amp;tqId=11195&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&amp;tqId=11195&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="built_in">array</span>.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            curSum = <span class="built_in">array</span>[left] + <span class="built_in">array</span>[right];</span><br><span class="line">            <span class="keyword">if</span>(curSum == sum)</span><br><span class="line">            &#123;</span><br><span class="line">               res.push_back(<span class="built_in">array</span>[left]);</span><br><span class="line">               res.push_back(<span class="built_in">array</span>[right]);  <span class="comment">//距离最远的两个数乘积最小</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curSum &gt; sum)</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curSum &lt; sum)</span><br><span class="line">                left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>证明距离越远的两个数乘积越小：</strong><br>假如 $x+y=c, c$是常数，并且假设$y\geq x, y-x=d,$即证明$d$越大，$x\times y$越小。<br>由以上知，$y=x+d$, 因此，$2x+d=c$,可得$x=\frac{c−d}{2}$, $y=x+d=\frac{c+d}{2}$。<br>$x\times y=\frac{c^2−d^2}{4}$, 所以，d越大，乘积越小.</p>
</blockquote>
<h3 id="11-左旋转字符串"><a href="#11-左旋转字符串" class="headerlink" title="11. 左旋转字符串"></a>11. 左旋转字符串</h3><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<p>来自 <a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&amp;tqId=11196&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&amp;tqId=11196&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        str += str;</span><br><span class="line">        n = n%len;</span><br><span class="line">        <span class="keyword">return</span> str.substr(n, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>附加：</strong> 翻转单词顺序，输入字符串”I am a student.”，输出”student. a am I”</p>
<p>解决办法：2次翻转。第一次翻转为”.tneduts a ma I”, 然后翻转每个单词。代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Class Solution&#123;</span><br><span class="line">Public:</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">reverseSentence</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">		<span class="built_in">string</span> revs = reverse(s);</span><br><span class="line">		<span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line">		<span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(revs)</span></span>;</span><br><span class="line">		<span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">		<span class="keyword">while</span>(getline(ss, <span class="keyword">word</span>, <span class="string">' '</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			res+=reverse(<span class="keyword">word</span>)+<span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res.substr(<span class="number">0</span>, len); <span class="comment">//去掉最后的空格</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">reverse</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(left&lt;right)</span><br><span class="line">			swap(s[left++], s[right--]);</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="12-扑克牌顺序"><a href="#12-扑克牌顺序" class="headerlink" title="12. 扑克牌顺序"></a>12. 扑克牌顺序</h3><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大小王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&amp;tqId=11198&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&amp;tqId=11198&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*思想：</span></span><br><span class="line"><span class="comment"> 1.对数组排序</span></span><br><span class="line"><span class="comment"> 2.统计数组中0的个数count</span></span><br><span class="line"><span class="comment"> 3.计算相邻元素的差值diff</span></span><br><span class="line"><span class="comment"> 4.如果存在相邻元素不为0，并且相等的情况，直接返回false</span></span><br><span class="line"><span class="comment"> 5.如果count&gt;=diff，返回true，否则，返回false */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.empty()) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        sort(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numbers.<span class="built_in">size</span>()<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                diff += numbers[i+<span class="number">1</span>] - numbers[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count&gt;=diff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="13-孩子们的游戏（圈中最后剩下的数字）"><a href="#13-孩子们的游戏（圈中最后剩下的数字）" class="headerlink" title="13. 孩子们的游戏（圈中最后剩下的数字）"></a>13. 孩子们的游戏（圈中最后剩下的数字）</h3><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<p>来自 <a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*方法1：构造环形列表，依次删除第m个，当指针指向it.end()时，另其重新指向begin(); */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span> || m&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            nums.push_back(i);</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); <span class="comment">//注意，此处必须是list，因为list删除后，指针仍然指向这个值，而vector删除后，迭代器会自动往后加</span></span><br><span class="line">        <span class="keyword">while</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                it++;</span><br><span class="line">                <span class="keyword">if</span>(it==nums.<span class="built_in">end</span>())</span><br><span class="line">                    it=nums.<span class="built_in">begin</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator next = ++it;</span><br><span class="line">            <span class="keyword">if</span>(next == nums.<span class="built_in">end</span>())</span><br><span class="line">                next = nums.<span class="built_in">begin</span>();</span><br><span class="line">            --it;</span><br><span class="line">            nums.erase(it);</span><br><span class="line">            it = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>方法2：推导出公式，其中f(n,m)表示从n中删除一个数字后剩余的数字。</p>
<script type="math/tex; mode=display">
    f(n,m)=\left\{ \begin{array}{l}
    &0 &,if \quad n=1 \\
    &[f(n-1,m)+m]\%n &,if \quad n>1\\
    \end{array}\right.</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span> || m&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (LastRemaining_Solution(n<span class="number">-1</span>, m) + m)%n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="14-求1-2-3-…-n"><a href="#14-求1-2-3-…-n" class="headerlink" title="14. 求1+2+3+…+n"></a>14. 求1+2+3+…+n</h3><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&amp;tqId=11200&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&amp;tqId=11200&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = n;</span><br><span class="line">        (n&gt;<span class="number">0</span>) &amp;&amp; (res += Sum_Solution(n<span class="number">-1</span>));   <span class="comment">//逻辑与功能，如果前面为真，则计算后边，否则，后边不计算</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="15-不使用加减乘除做加法"><a href="#15-不使用加减乘除做加法" class="headerlink" title="15. 不使用加减乘除做加法"></a>15. 不使用加减乘除做加法</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*思路：</span></span><br><span class="line"><span class="comment">	1. 两个数异或：相当于每一位相加，而不考虑进位；</span></span><br><span class="line"><span class="comment">	2. 两个数相与，并左移一位：相当于求得进位；</span></span><br><span class="line"><span class="comment">	3. 将上述两步的结果相加</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	来自 &lt;https://www.nowcoder.com/questionTerminal/59ac416b4b944300b617d4f7f111b215&gt; */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = num1 ^ num2;</span><br><span class="line">            <span class="keyword">int</span> carry = (num1 &amp; num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            num1 = sum;</span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="16-把字符串转化为整数"><a href="#16-把字符串转化为整数" class="headerlink" title="16. 把字符串转化为整数"></a>16. 把字符串转化为整数</h3><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
<p>输入描述:<br>输入一个字符串,包括数字字母符号,可以为空</p>
<p>输出描述:<br>如果是合法的数值表达则返回该数字，否则返回0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flg = <span class="number">1</span>; <span class="comment">//标记是否为正负</span></span><br><span class="line">        <span class="keyword">int</span> beg = <span class="number">0</span>; <span class="comment">//判断索引是从0开始还是1开始</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flg = <span class="number">-1</span>;</span><br><span class="line">            beg = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'+'</span>)</span><br><span class="line">            beg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=beg; i&lt;len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]&gt;=<span class="string">'0'</span> &amp;&amp; str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                res = res * <span class="number">10</span> + str[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * flg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="17-寻找重复数字"><a href="#17-寻找重复数字" class="headerlink" title="17. 寻找重复数字"></a>17. 寻找重复数字</h3><p>题目描述<br>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1：使用map，缺点需开辟额外空间，时间复杂度O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *duplication = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[numbers[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(mp[numbers[i]]&gt;=<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        *duplication = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><strong>很好的思想，复习时一定查看</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法2：无需开辟新的空间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *duplication = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = numbers[i];   <span class="comment">//令索引等于第i个数字</span></span><br><span class="line">            <span class="keyword">if</span>(index &gt;= length)</span><br><span class="line">                index -= length;           <span class="comment">// 如果该索引大于length，则减length</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[index] &gt;= length)</span><br><span class="line">            &#123;</span><br><span class="line">                *duplication = index;   <span class="comment">//如果索引指向的值大于length，则该索引就是重复的那个数，因为前边肯定有相同的索引指向了这个元素，例如[2,3,1,0,2,5,3], 第一个索引2指向的值numbers[2] = 1,然后让其加上length，变为1+7=8。当下一个索引2指向该值时，该值&gt;=length,说明前面肯定存在2，故可以直接返回，而不需要开辟新的空间  </span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            numbers[index] += length;</span><br><span class="line">        &#125;</span><br><span class="line">        *duplication = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="18-构建乘积数组"><a href="#18-构建乘积数组" class="headerlink" title="18. 构建乘积数组"></a>18. 构建乘积数组</h3><p>题目描述:<br>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&amp;tqId=11204&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&amp;tqId=11204&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a> </p>
<p><img src="./images/构建乘积数组.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span>：先计算下三角，再计算上三角，然后相乘</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">down</span><span class="params">(A.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up</span><span class="params">(A.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;A.<span class="built_in">size</span>(); i++)</span><br><span class="line">            down[i] = down[i<span class="number">-1</span>] * A[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=A.<span class="built_in">size</span>()<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            up[i] = up[i+<span class="number">1</span>] * A[i+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res(A.<span class="built_in">size</span>(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i++)</span><br><span class="line">            res[i] = down[i] * up[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法2：节省开辟空间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">down</span><span class="params">(A.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;A.<span class="built_in">size</span>(); i++)</span><br><span class="line">            down[i] = down[i<span class="number">-1</span>] * A[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=A.<span class="built_in">size</span>()<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = tmp * A[i+<span class="number">1</span>];</span><br><span class="line">            down[i] = tmp * down[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> down;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="19-正则表达式的匹配"><a href="#19-正则表达式的匹配" class="headerlink" title="19. 正则表达式的匹配"></a>19. 正则表达式的匹配</h3><p>题目描述<br>请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<p>来自 <a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&amp;tqId=11205&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&amp;tqId=11205&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    解这题需要把题意仔细研究清楚，反正我试了好多次才明白的。</span></span><br><span class="line"><span class="comment">    首先，考虑特殊情况：</span></span><br><span class="line"><span class="comment">         1&gt;两个字符串都为空，返回true</span></span><br><span class="line"><span class="comment">         2&gt;当第一个字符串不空，而第二个字符串空了，返回false（因为这样，就无法</span></span><br><span class="line"><span class="comment">            匹配成功了,而如果第一个字符串空了，第二个字符串非空，还是可能匹配成</span></span><br><span class="line"><span class="comment">            功的，比如第二个字符串是“a*a*a*a*”,由于‘*’之前的元素可以出现0次，</span></span><br><span class="line"><span class="comment">            所以有可能匹配成功）</span></span><br><span class="line"><span class="comment">    之后就开始匹配第一个字符，这里有两种可能：匹配成功或匹配失败。但考虑到pattern</span></span><br><span class="line"><span class="comment">    下一个字符可能是‘*’， 这里我们分两种情况讨论：pattern下一个字符为‘*’或</span></span><br><span class="line"><span class="comment">    不为‘*’：</span></span><br><span class="line"><span class="comment">          1&gt;pattern下一个字符不为‘*’：这种情况比较简单，直接匹配当前字符。如果</span></span><br><span class="line"><span class="comment">            匹配成功，继续匹配下一个；如果匹配失败，直接返回false。注意这里的</span></span><br><span class="line"><span class="comment">            “匹配成功”，除了两个字符相同的情况外，还有一种情况，就是pattern的</span></span><br><span class="line"><span class="comment">            当前字符为‘.’,同时str的当前字符不为‘\0’。</span></span><br><span class="line"><span class="comment">          2&gt;pattern下一个字符为‘*’时，稍微复杂一些，因为‘*’可以代表0个或多个。</span></span><br><span class="line"><span class="comment">            这里把这些情况都考虑到：</span></span><br><span class="line"><span class="comment">               a&gt;当‘*’匹配0个字符时，str当前字符不变，pattern当前字符后移两位，</span></span><br><span class="line"><span class="comment">                跳过这个‘*’符号；</span></span><br><span class="line"><span class="comment">               b&gt;当‘*’匹配1个或多个时，str当前字符移向下一个，pattern当前字符</span></span><br><span class="line"><span class="comment">                不变。（这里匹配1个或多个可以看成一种情况，因为：当匹配一个时，</span></span><br><span class="line"><span class="comment">                由于str移到了下一个字符，而pattern字符不变，就回到了上边的情况a；</span></span><br><span class="line"><span class="comment">                当匹配多于一个字符时，相当于从str的下一个字符继续开始匹配）</span></span><br><span class="line"><span class="comment">    之后再写代码就很简单了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如果pattern的下一个不等于‘*’</span></span><br><span class="line">        <span class="keyword">if</span>(*(pattern+<span class="number">1</span>) != <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*str == *pattern || (*str!=<span class="string">'\0'</span> &amp;&amp; *pattern==<span class="string">'.'</span>))</span><br><span class="line">                <span class="keyword">return</span> match(str+<span class="number">1</span>, pattern+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">// if(*(pattern+1) == '*')//如果pattern的下一个等于‘*’</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*str == *pattern || (*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'.'</span>))</span><br><span class="line">                <span class="keyword">return</span> match(str+<span class="number">1</span>, pattern) || match(str, pattern+<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> match(str, pattern+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="20-链表中环的入口节点"><a href="#20-链表中环的入口节点" class="headerlink" title="20. 链表中环的入口节点"></a>20. 链表中环的入口节点</h3><p>题目描述<br>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;tqId=11208&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;tqId=11208&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        采用快慢指针的方法，另快指针一次移动两个，慢指针一次移动一个。</span></span><br><span class="line"><span class="comment">        如果两者能够相遇说明存在环。否则，当fast为NULL时,代表不存在环。</span></span><br><span class="line"><span class="comment">        当两者相遇后，慢指针不动，另快指针指向链表头，并且每次快慢指针都</span></span><br><span class="line"><span class="comment">        只移动一次，当两者再次相遇时，指向的就是环的入口结点。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(!pHead || !(pHead-&gt;next)|| !(pHead-&gt;next-&gt;next))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* slow = pHead-&gt;next;</span><br><span class="line">        ListNode* fast = pHead-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法2： 使用哈希表，需开辟O(n)空间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;ListNode*, <span class="keyword">int</span>&gt;mp;</span><br><span class="line">        ListNode* ptr = pHead;</span><br><span class="line">        <span class="keyword">while</span>(ptr!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[ptr]++;</span><br><span class="line">            <span class="keyword">if</span>(mp[ptr]&gt;=<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            ptr=ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*来自 &lt;https://www.nowcoder.com/profile/490351159/codeBookDetail?submissionId=35500459&gt; */</span></span><br></pre></td></tr></table></figure>
<h3 id="21-Longest-Common-Sequence-最长公共子序列-多次遇见"><a href="#21-Longest-Common-Sequence-最长公共子序列-多次遇见" class="headerlink" title="21. Longest Common Sequence(最长公共子序列)(多次遇见)"></a>21. Longest Common Sequence(最长公共子序列)(多次遇见)</h3><p>给定两个字符串，求解这两个字符串的最长公共子序列（不要求连续）。比如：s1 = BDCABA，s2 = ABCBDAB<br>则这两个字符串的最长公共子序列长度为4，最长公共子序列为：BCBA（任意一个就行）</p>
<p>求解方式：<br>这是一个动态规划的题目。对于可用动态规划求解的问题，一般有两个特征：①最优子结构；②重叠子问题</p>
<p><strong>①最优子结构:</strong></p>
<p>设 $X=(x_1,x_2,…..x_n)$ 和 $Y={y_1,y_2,…..y_m}$ 是两个序列，将 X和Y的最长公共子序列记为$LCS(X,Y)$<br>找出$LCS(X,Y)$就是一个最优化问题。因为，我们需要找到X 和 Y中最长的那个公共子序列。而要找X 和 Y的LCS，首先考虑X的最后一个元素和Y的最后一个元素。</p>
<ul>
<li>如果 $x<em>n=y_m$，即X的最后一个元素与Y的最后一个元素相同，这说明该元素一定位于公共子序列中。因此，现在只需要找：$LCS(X</em>{n-1}，Y<em>{m-1})$。$LCS(X</em>{n-1}，Y<em>{m-1})$就是原问题的一个子问题。为什么叫子问题？因为它的规模比原问题小。（小一个元素也是小嘛….）<br>为什么是最优的子问题？因为我们要找的是$X</em>{n-1}$ 和 $Y_{m-1}$ 的最长公共子序列啊。。。最长的！！！换句话说，就是最优的那个。（这里的最优就是最长的意思）</li>
<li><p>如果$x<em>n \neq y_m$，这下要麻烦一点，因为它产生了两个子问题：$LCS(X</em>{n-1}，Y<em>m)$和$LCS(X_n，Y</em>{m-1})$.<br>因为序列X 和 序列Y 的最后一个元素不相等嘛，那说明最后一个元素不可能是最长公共子序列中的元素嘛。（都不相等了，怎么公共嘛）。</p>
<ul>
<li><p>$LCS(X<em>{n-1}，Y_m)$表示：最长公共序列可以在$(x_1,x_2,….x</em>{n-1})$和 (y_1,y_2,…,y_n)中找。</p>
</li>
<li><p>$LCS(X<em>n,Y</em>{m-1})$表示：最长公共序列可以在$(x<em>1,x_2,…,x_n)$和$(y_1,y_2,…,y</em>{n-1})$中找。</p>
</li>
</ul>
</li>
</ul>
<p>求解上面两个子问题，得到的公共子序列谁最长，那谁就是 $LCS(X,Y)$。用数学表示就是：<br>$LCS=\max{LCS(X<em>{n-1}，Y_m),LCS(X_n，Y</em>{m-1})}$.<br>由于上述两个条件考虑到了所有可能的情况。因此，我们成功地把原问题 转化 成了 三个规模更小的子问题。</p>
<p><strong>②重叠子问题：</strong></p>
<p>重叠子问题是啥？就是说原问题 转化 成子问题后，  子问题中有相同的问题。咦？我怎么没有发现上面的三个子问题中有相同的啊？？？？<br>OK，来看看，原问题是：$LCS(X,Y)$。子问题有 ❶$LCS(X<em>{n-1},Y</em>{m-1})$    ❷$LCS(X<em>{n-1},Y_m)$  ❸$LCS(X_n,Y</em>{m-1})$<br>初一看，这三个子问题是不重叠的。可本质上它们是重叠的，因为它们只重叠了一大部分。举例：<br>第二个子问题：$LCS(X<em>{n-1},Y_m)$ 就包含了：问题❶$LCS(X</em>{n-1},Y<em>{m-1})$，为什么？<br>因为，当$X</em>{n-1}$ 和 $Y<em>m$ 的最后一个元素不相同时，我们又需要将$LCS(X</em>{n-1}，Y<em>m)$进行分解：分解成：$LCS(X</em>{n-1},Y<em>{m-1})$ 和 $LCS(X</em>{n-2},Y_m)$.</p>
<p>也就是说：在子问题的继续分解中，有些问题是重叠的。<br><img src="./images/最优子结构.png" alt><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">	<span class="keyword">int</span> len1 = s1.<span class="built_in">size</span>(), len2 = s2.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;nums(len1+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len1; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=len2; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				nums[i][j] = nums[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(nums[i][j<span class="number">-1</span>]&gt;nums[i<span class="number">-1</span>][j])</span><br><span class="line">				nums[i][j] = nums[i][j<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				nums[i][j] = nums[i<span class="number">-1</span>][j];</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此时，nums[len1][len2]中保存的就是最长公共子序列的长度，要想得到任意最长公共子序列的字符串，则需继续进行以下步骤;</span></span><br><span class="line">	<span class="keyword">int</span> k = len1;</span><br><span class="line">	<span class="keyword">int</span> j = len2;</span><br><span class="line">	<span class="keyword">while</span> (k &gt;=<span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	      <span class="keyword">if</span> (s1[k] == s2[j]) </span><br><span class="line">	      &#123;  </span><br><span class="line">		res+=s1[k];</span><br><span class="line">		k--;</span><br><span class="line">	            j--;</span><br><span class="line">	      &#125;</span><br><span class="line">	     <span class="keyword">else</span> </span><br><span class="line">	     &#123;</span><br><span class="line">	            <span class="keyword">if</span> (nums[k][j - <span class="number">1</span>] &gt; nums[k - <span class="number">1</span>][j]) </span><br><span class="line">	                j--;  </span><br><span class="line">	            <span class="keyword">else</span> </span><br><span class="line">	                k--;</span><br><span class="line">	      &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="22-删除链表中的重复节点"><a href="#22-删除链表中的重复节点" class="headerlink" title="22. 删除链表中的重复节点"></a>22. 删除链表中的重复节点</h3><p>题目描述<br>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead || !(pHead-&gt;next))</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode* cur;</span><br><span class="line">        <span class="keyword">if</span>(pHead-&gt;val == pHead-&gt;next-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = pHead-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(cur &amp;&amp; cur-&gt;val == pHead-&gt;val)</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplication(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pHead-&gt;next = deleteDuplication(pHead-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="23-镜像二叉树"><a href="#23-镜像二叉树" class="headerlink" title="23. 镜像二叉树"></a>23. 镜像二叉树</h3><p>题目描述<br>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&amp;tqId=11211&amp;rp=3&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;tPage=3" target="_blank" rel="noopener">https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&amp;tqId=11211&amp;rp=3&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;tPage=3</a> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetrical(TreeNode* pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        return help(pRoot, pRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    bool help(TreeNode* root1, TreeNode* root2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!root1 &amp;&amp; !root2)</span><br><span class="line">            return true;</span><br><span class="line">        if(!root1 || !root2)</span><br><span class="line">            return false;</span><br><span class="line">        if(root1-&gt;val !&#x3D; root2-&gt;val)</span><br><span class="line">            return false;</span><br><span class="line">        return help(root1-&gt;left, root2-&gt;right) &amp;&amp; help(root1-&gt;right, root2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="24-按之字形顺序打印二叉树"><a href="#24-按之字形顺序打印二叉树" class="headerlink" title="24. 按之字形顺序打印二叉树"></a>24. 按之字形顺序打印二叉树</h3><p>题目描述<br>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&amp;tqId=11212&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&amp;tqId=11212&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        if(!pRoot) return res;</span><br><span class="line">        stack&lt;TreeNode*&gt; s1; &#x2F;&#x2F;s1 入栈顺序先右后左</span><br><span class="line">        s1.push(pRoot);</span><br><span class="line">        stack&lt;TreeNode*&gt; s2; &#x2F;&#x2F;s2 入栈顺序先左后右</span><br><span class="line">        while(!s1.empty() || !s2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt;tmp;</span><br><span class="line">            int len;</span><br><span class="line">            if(s1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                len &#x3D; s2.size();</span><br><span class="line">                for(int i&#x3D;0; i&lt;len; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* top &#x3D; s2.top();</span><br><span class="line">                    s2.pop();</span><br><span class="line">                    tmp.push_back(top-&gt;val);</span><br><span class="line">                    if(top-&gt;right) s1.push(top-&gt;right);</span><br><span class="line">                    if(top-&gt;left) s1.push(top-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                len &#x3D; s1.size();</span><br><span class="line">                for(int i&#x3D;0; i&lt;len; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* t &#x3D; s1.top();</span><br><span class="line">                    s1.pop();</span><br><span class="line">                    tmp.push_back(t-&gt;val);</span><br><span class="line">                    if(t-&gt;left) s2.push(t-&gt;left);</span><br><span class="line">                    if(t-&gt;right) s2.push(t-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="25-动态规划解决找零钱问题-作业帮面试题"><a href="#25-动态规划解决找零钱问题-作业帮面试题" class="headerlink" title="25. 动态规划解决找零钱问题(作业帮面试题)"></a>25. 动态规划解决找零钱问题(作业帮面试题)</h3><p>在现实生活中，经常遇到找零问题，假设有数目不限的面值为1元，2元，5元，10元等等的硬币。给出需要找零金额，求出找零方案，要求：使用的硬币数目最少。</p>
<p>来自 <a href="https://blog.csdn.net/niaonao/article/details/78249256" target="_blank" rel="noopener">https://blog.csdn.net/niaonao/article/details/78249256</a> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_coins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> money)</span>  	<span class="comment">//讲解：nums中是现有的金钱面值，money是要找的零钱。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(money&lt;=<span class="number">0</span> || nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">coins</span><span class="params">(money+<span class="number">1</span>, <span class="number">0</span>)</span></span>;  	<span class="comment">//存放的是对于每一个面值需要的最少张数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=money; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mincoin = i;			<span class="comment">//指当全部使用1元时需要的张数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[j] &lt;= i)</span><br><span class="line">				mincoin = <span class="built_in">min</span>(mincoin, coins[i - nums[j]] + <span class="number">1</span>); 	<span class="comment">//选择使用较少的张数，并存于coins数组中</span></span><br><span class="line">		&#125;</span><br><span class="line">		coins[i] = mincoin;	<span class="comment">//更新零钱为i时需要的最小的张数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> coins[money];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-旋转数组的最小数字"><a href="#26-旋转数组的最小数字" class="headerlink" title="26. 旋转数组的最小数字"></a>26. 旋转数组的最小数字</h3><p>题目描述:<br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>链接：<a href="https://www.nowcoder.com/questionTerminal/9f3231a991af4f55b95579b44b7a01ba" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/9f3231a991af4f55b95579b44b7a01ba</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*采用二分法解答这个问题，  </span></span><br><span class="line"><span class="comment">mid = low + (high - low)/2 </span></span><br><span class="line"><span class="comment">需要考虑三种情况： </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(1) array[mid] &gt; array[high]: </span></span><br><span class="line"><span class="comment">出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。 </span></span><br><span class="line"><span class="comment">low = mid + 1 </span></span><br><span class="line"><span class="comment">(2) array[mid] == array[high]: </span></span><br><span class="line"><span class="comment">出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边 </span></span><br><span class="line"><span class="comment">还是右边,这时只好一个一个试 ， </span></span><br><span class="line"><span class="comment">high = high - 1 </span></span><br><span class="line"><span class="comment">(3) array[mid] &lt; array[high]: </span></span><br><span class="line"><span class="comment">出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左 </span></span><br><span class="line"><span class="comment">边。因为右边必然都是递增的。 </span></span><br><span class="line"><span class="comment">high = mid </span></span><br><span class="line"><span class="comment">注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字 </span></span><br><span class="line"><span class="comment">比如 array = [4,6] </span></span><br><span class="line"><span class="comment">array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ; </span></span><br><span class="line"><span class="comment">如果high = mid - 1，就会产生错误， 因此high = mid </span></span><br><span class="line"><span class="comment">但情形(1)中low = mid + 1就不会错误*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">每次都用中间的数跟最右边的比较，</span></span><br><span class="line"><span class="comment">1）如果mid大于右边则说明最小值在右边，left=mid+1</span></span><br><span class="line"><span class="comment">2）如果mid小于右边则说明最小值在mid或mid的左边，right = mid</span></span><br><span class="line"><span class="comment">3）如果mid等于右边，此时不好说明最小值在mid左边还是右边，只能顺序查找，right--</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray.<span class="built_in">size</span>()&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = rotateArray.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//if(rotateArray[left] &lt; rotateArray[right]) return rotateArray[left];</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt; rotateArray[right])</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] == rotateArray[right])</span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="27-重建二叉树（已知先序和后序）"><a href="#27-重建二叉树（已知先序和后序）" class="headerlink" title="27. 重建二叉树（已知先序和后序）"></a>27. 重建二叉树（已知先序和后序）</h3><p>题目描述:<br>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> help(pre, <span class="number">0</span>, pre.<span class="built_in">size</span>()<span class="number">-1</span>, vin, <span class="number">0</span>, vin.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vin, <span class="keyword">int</span> il, <span class="keyword">int</span> ir)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl&gt;pr || il&gt;ir) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* pHead = <span class="keyword">new</span> TreeNode(pre[pl]);</span><br><span class="line">        TreeNode* ptr = pHead;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=il; i&lt;=ir; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vin[i] == pre[pl])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pl1 = pl + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pr1 = i - il + pl;</span><br><span class="line">        <span class="keyword">int</span> il1 = il;</span><br><span class="line">        <span class="keyword">int</span> ir1 = i - <span class="number">1</span>;</span><br><span class="line">        ptr-&gt;left = help(pre, pl1, pr1, vin, il1, ir1);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pl2 = pl + i - il + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pr2 = pr;</span><br><span class="line">        <span class="keyword">int</span> il2 = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ir2 = ir;</span><br><span class="line">        ptr-&gt;right = help(pre, pl2, pr2, vin, il2, ir2);</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="28-调整数组顺序使奇数位于偶数前面"><a href="#28-调整数组顺序使奇数位于偶数前面" class="headerlink" title="28. 调整数组顺序使奇数位于偶数前面"></a>28. 调整数组顺序使奇数位于偶数前面</h3><p>题目描述:<br>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.要想保证原有次序，则只能顺次移动或相邻交换。</span></span><br><span class="line"><span class="comment"> * 2.i从左向右遍历，找到第一个偶数。</span></span><br><span class="line"><span class="comment"> * 3.j从i+1开始向后找，直到找到第一个奇数。</span></span><br><span class="line"><span class="comment"> * 4.将[i,...,j-1]的元素整体后移一位，最后将找到的奇数放入i位置，然后i++。</span></span><br><span class="line"><span class="comment"> * 5.終止條件：j向後遍歷查找失敗。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">array</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;len &amp;&amp; !isEven(<span class="built_in">array</span>[i]))</span><br><span class="line">                i++;</span><br><span class="line">            j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;len &amp;&amp; isEven(<span class="built_in">array</span>[j]))</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;len)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="built_in">array</span>[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j; k&gt;i; k--)</span><br><span class="line">                    <span class="built_in">array</span>[k] = <span class="built_in">array</span>[k<span class="number">-1</span>];</span><br><span class="line">                <span class="built_in">array</span>[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="29-二叉树遍历的递归与非递归（前序、中序、后序）"><a href="#29-二叉树遍历的递归与非递归（前序、中序、后序）" class="headerlink" title="29.二叉树遍历的递归与非递归（前序、中序、后序）"></a>29.二叉树遍历的递归与非递归（前序、中序、后序）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.递归实现前序遍历*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder1</span><span class="params">(BinTree *root)</span>     <span class="comment">//递归前序遍历 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        preOrder1(root-&gt;lchild);</span><br><span class="line">        preOrder1(root-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*2.非递归实现前序遍历</span></span><br><span class="line"><span class="comment">对于任一结点P：</span></span><br><span class="line"><span class="comment">     1)访问结点P，并将结点P入栈;</span></span><br><span class="line"><span class="comment">     2)判断结点P的左孩子是否为空，若为空，则取栈顶结点并进行出栈操作，并将栈顶结点的右孩子置为当前的结点P，循环至1);若不为空，则将P的左孩子置为当前的结点P;</span></span><br><span class="line"><span class="comment">     3)直到P为NULL并且栈为空，则遍历结束。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder2</span><span class="params">(BinTree *root)</span>     <span class="comment">//非递归前序遍历 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinTree*&gt; s;</span><br><span class="line">    BinTree *p=root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            p=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.递归实现中序遍历*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder1</span><span class="params">(BinTree *root)</span>      <span class="comment">//递归中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inOrder1(root-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        inOrder1(root-&gt;rchild);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.非递归实现中序遍历*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder2</span><span class="params">(BinTree *root)</span>      <span class="comment">//非递归中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinTree*&gt; s;</span><br><span class="line">    BinTree *p=root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            p=s.top();</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.后序遍历的递归实现*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder1</span><span class="params">(BinTree *root)</span>    <span class="comment">//递归后序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postOrder1(root-&gt;lchild);</span><br><span class="line">        postOrder1(root-&gt;rchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.后序遍历的非递归实现</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存 在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了 每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder3</span><span class="params">(BinTree *root)</span>     <span class="comment">//非递归后序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinTree*&gt; s;</span><br><span class="line">    BinTree *cur;                      <span class="comment">//当前结点 </span></span><br><span class="line">    BinTree *pre=<span class="literal">NULL</span>;                 <span class="comment">//前一次访问的结点 </span></span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        cur=s.top();</span><br><span class="line">        <span class="keyword">if</span>((cur-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;cur-&gt;rchild==<span class="literal">NULL</span>)||</span><br><span class="line">           (pre!=<span class="literal">NULL</span>&amp;&amp;(pre==cur-&gt;lchild||pre==cur-&gt;rchild)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;cur-&gt;data&lt;&lt;<span class="string">" "</span>;  <span class="comment">//如果当前结点没有孩子结点或者孩子节点都已被访问过 </span></span><br><span class="line">              s.pop();</span><br><span class="line">            pre=cur; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">                s.push(cur-&gt;rchild);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;lchild!=<span class="literal">NULL</span>)    </span><br><span class="line">                s.push(cur-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="30-数组中只出现一次的数字"><a href="#30-数组中只出现一次的数字" class="headerlink" title="30. 数组中只出现一次的数字"></a>30. 数组中只出现一次的数字</h3><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = data.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = data[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)</span><br><span class="line">            tmp ^= data[i];</span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((tmp&amp;<span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = tmp&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        *num1=<span class="number">0</span>, *num2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isBit(data[i], index))</span><br><span class="line">                *num1 ^= data[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *num2 ^= data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n=n&gt;&gt;index;</span><br><span class="line">        <span class="keyword">return</span> (n&amp;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="31-二叉搜索树的第k个节点"><a href="#31-二叉搜索树的第k个节点" class="headerlink" title="31.二叉搜索树的第k个节点"></a>31.二叉搜索树的第k个节点</h3><p>题目描述:<br>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt;s;</span><br><span class="line">        TreeNode* p = pRoot;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p || !s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(p)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(p);</span><br><span class="line">                p=p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                p = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">if</span>(index==k)</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* node = KthNode(pRoot-&gt;left, k);</span><br><span class="line">        <span class="keyword">if</span>(node) <span class="keyword">return</span> node;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count==k) <span class="keyword">return</span> pRoot;</span><br><span class="line">        node = KthNode(pRoot-&gt;right, k);</span><br><span class="line">        <span class="keyword">if</span>(node) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="32-二叉搜索树与双向链表"><a href="#32-二叉搜索树与双向链表" class="headerlink" title="32. 二叉搜索树与双向链表"></a>32. 二叉搜索树与双向链表</h3><p>题目描述<br>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* root = pRootOfTree;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() || pRootOfTree)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(pRootOfTree)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(pRootOfTree);</span><br><span class="line">                pRootOfTree = pRootOfTree-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                pRootOfTree = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span>(!pre)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = pRootOfTree;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    pre-&gt;right = pRootOfTree;</span><br><span class="line">                    pRootOfTree-&gt;left = pre;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = pRootOfTree;</span><br><span class="line">                pRootOfTree = pRootOfTree-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="33-快速排序："><a href="#33-快速排序：" class="headerlink" title="33. 快速排序："></a>33. 快速排序：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> piv = nums[left];</span><br><span class="line">    <span class="keyword">int</span> low = left, high = right;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; piv&lt;=nums[high])</span><br><span class="line">            high--;</span><br><span class="line">        nums[low] = nums[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; piv&gt;=nums[low])</span><br><span class="line">            low++;</span><br><span class="line">        nums[high] = nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[low] = piv;</span><br><span class="line">    qsort(nums, left, low<span class="number">-1</span>);</span><br><span class="line">    qsort(nums, low+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/18/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E6%80%A7/" class="post-title-link" itemprop="url">拉格朗日对偶性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 21:41:36" itemprop="dateCreated datePublished" datetime="2020-06-18T21:41:36+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-11 01:41:36" itemprop="dateModified" datetime="2019-08-11T01:41:36+08:00">2019-08-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="拉格朗日对偶性"><a href="#拉格朗日对偶性" class="headerlink" title="拉格朗日对偶性"></a>拉格朗日对偶性</h2><p>在约束最优化问题中，常常利用拉格朗日对偶性（Lagrange duaiity）将原始问题转化为对偶问题，通过解对偶问题而得到原始问题的解。该方法应用在许多统计学习方法中，如最大熵模型与支持向量机。</p>
<h3 id="1-原始问题"><a href="#1-原始问题" class="headerlink" title="1.原始问题"></a><strong>1.原始问题</strong></h3><p>假设$f(x),c_i(x),h_j(x)$是定义在$\mathbf{R}^n$上的连续可微函数，考虑约束最优化问题：</p>
<script type="math/tex; mode=display">
\min_{x\in\mathbf{R}^n}f(x) \tag{1}</script><script type="math/tex; mode=display">
s.t. \quad c_i(x)\leq0, i=1,2,...,k \tag{2}</script><script type="math/tex; mode=display">
\qquad h_j(x)=0,j=1,2,...,l \tag{3}</script><p>称此约束最优化问题为原始最优化问题或原始问题。</p>
<p>引入朗格朗日函数：</p>
<script type="math/tex; mode=display">
L(x,\alpha,\beta)=f(x)+\sum_{i=1}^{k}\alpha_ic_i(x)+\sum_{j=1}^{l}\beta_jh_j(x) \tag{4}</script><p>这里，$x=(x^{(1)},x^{(2)},…,x^{(n)})^T\in\mathbf{R}^n,\alpha_i,\beta_j$是朗格朗日乘子，$\alpha_i\geq0$。考虑$x$的函数：</p>
<script type="math/tex; mode=display">
\theta_P(x)=\max_{\alpha,\beta:\alpha_i\geq0}L(x,\alpha,\beta)=\left\{\begin{matrix}
 & f(x), & x满足原始问题约束\\ 
 & +\infty &其他 
\end{matrix}\right. \tag{5}</script><p>这里下标$P$表示原始问题。</p>
<blockquote>
<p><strong>公式5说明：</strong> </p>
<p>假如给定某个$x$，如果$x$违反原始问题的约束条件，即存在某个$i$使得$c_i(x)&gt;0$或者存在某个$j$使得$h_j(x)\neq0$。当$c_i(x)&gt;0$且$h_j(x)\neq0$时，令$\alpha_i\rightarrow+\infin,\beta_jh_j(x)\rightarrow+\infin$,而其余各$\alpha_i,\beta_j$均取0，此时</p>
<script type="math/tex; mode=display">
\theta_P(x)=\max_{\alpha,\beta:\alpha_i\geq0}L(x,\alpha,\beta)=+\infin</script><p>相反地，如果$x$满足约束条件式2和式3，则：</p>
<script type="math/tex; mode=display">
max(\sum_{i=1}^{k}\alpha_ic_i(x)+\sum_{j=1}^{l}\beta_jh_j(x))=0</script><p>所以</p>
<script type="math/tex; mode=display">
\theta_P(x)=\max_{\alpha,\beta:\alpha_i\geq0}L(x,\alpha,\beta)=f(x)</script><p>因此，原始问题(式1~3)可以转化为：</p>
<script type="math/tex; mode=display">
\min_{x}\theta_P(x)=\min_{x}\max_{\alpha,\beta:\alpha_i\geq0}L(x,\alpha,\beta) \tag{6}</script><p>它是与原始问题等价的，即它们有相同的解。问题</p>
<script type="math/tex; mode=display">\min_{x}\max_{\alpha,\beta:\alpha_i\geq0}L(x,\alpha,\beta)</script><p>称为广义拉格朗日函数的极小极大问题。这样一来，就把原始最优化问题表示为广义拉格朗日函数的极小极大问题。为了方便，定义原始问题的最优解值为:</p>
<script type="math/tex; mode=display">
p^*=\min_x\theta_P(x) \tag{7}</script><h3 id="2-对偶问题"><a href="#2-对偶问题" class="headerlink" title="2.对偶问题"></a><strong>2.对偶问题</strong></h3><p>定义</p>
<script type="math/tex; mode=display">
\theta_D(\alpha,\beta)=\min_xL(x,\alpha,\beta) \tag{8}</script><p>再考虑极大化$\theta_D(\alpha,\beta)$，即</p>
<script type="math/tex; mode=display">
\max_{\alpha,\beta:\alpha_i\geq0}\theta_D(\alpha,\beta)=\max_{\alpha,\beta:\alpha_i\geq0}\min_xL(x,\alpha,\beta) \tag{9}</script><p>称为广义拉格朗日函数的极大极小问题，表示为约束最优化问题：</p>
<script type="math/tex; mode=display">
\max_{\alpha,\beta}\theta_D(\alpha,\beta)=\max_{\alpha,\beta}\min_xL(x,\alpha,\beta) \tag{10}</script><script type="math/tex; mode=display">
s.t. \quad \alpha_i\geq0,i=1,2,...,k \tag{11}</script><p>称为原始问题的对偶问题，定义对偶问题的最优值为：</p>
<script type="math/tex; mode=display">
d^*=\max_{\alpha,\beta:\alpha_i\geq0}\theta_D(\alpha,\beta) \tag{12}</script><p>可以看出原始问题与对偶问题的变量并不相同，对于原始问题，它的变量是$x$，而对于对偶问题，它的变量是$\alpha,\beta$。这两个问题并不等价，有时可能相差甚远。可以理解为慢班中学习最好的学生都没有快班中学习最差的学生学习好(当然，这不一定是事实，只是一个比喻)。</p>
<h3 id="3-原始问题与对偶问题的关系"><a href="#3-原始问题与对偶问题的关系" class="headerlink" title="3.原始问题与对偶问题的关系"></a><strong>3.原始问题与对偶问题的关系</strong></h3><p>对偶函数可以理解为给原始函数找了一个下界，在原始函数计算困难的时候，可以通过解对偶函数来得到一个近似的值。并且在函数满足一定条件的时候，对偶函数的解与原始函数的解是等价的。</p>
</blockquote>
<p><strong>定理1</strong> 若原始问题与对偶问题都有最优值，则</p>
<script type="math/tex; mode=display">
d^*=\max_{\alpha,\beta:\alpha_i\geq0}\min_xL(x,\alpha,\beta)\leq \min_{x}\max_{\alpha,\beta:\alpha_i\geq0}L(x,\alpha,\beta)=p^* \tag{13}</script><blockquote>
<p>证明：对任意的$\alpha,\beta,x$,有</p>
<script type="math/tex; mode=display">
\theta_D(\alpha,\beta)=\min_xL(x,\alpha,\beta)\leq L(x,\alpha,\beta)\leq \max_{\alpha,\beta:\alpha_i\geq0}L(x,\alpha,\beta)=\theta_P(x)</script><p>即</p>
<script type="math/tex; mode=display">
\theta_D(\alpha,\beta)\leq  \theta_P(x) \tag{14}</script><p>由于原始问题与对偶问题都有最优值($\theta_D(\alpha,\beta)$可以理解为慢班中的学生，$\theta_P(x)$可以理解为快班中的学生，那么慢班中学习最好的学生都不一定有快班中学习最差的学生学习好），所以</p>
<script type="math/tex; mode=display">
\max_{\alpha,\beta:\alpha_i\geq0}\theta_D(\alpha,\beta)\leq \min_x\theta_P(x)</script><p>即</p>
<script type="math/tex; mode=display">
d^*=\max_{\alpha,\beta:\alpha_i\geq0}\min_xL(x,\alpha,\beta)\leq \min_{x}\max_{\alpha,\beta:\alpha_i\geq0}L(x,\alpha,\beta)=p^*</script><p>这个性质便是弱对偶性（ weak duality ）。弱对偶性对任何优化问题都成立，这似乎是显然的，因为这个下界并不严格，有时候甚至取到非常小，对原始问题的解没多大帮助。既有弱对偶性，那么便有强对偶性，强对偶性是指</p>
<script type="math/tex; mode=display">
d^* = p^*</script><p><strong>定理2</strong> 考虑原始问题式1~3和对偶问题式10~11，假设<font color="#0000FF"><strong>函数$f(x)$和$c_i(x)$是凸函数，$h_j(x)$是仿射函数；并且假设不等式约束$c_i(x)$是严格可行的，即存在$x$，对所有$i$有$c_i(x)&lt;0$</strong></font><font color="#FF0000"> (slater条件)</font>,则存在$x^<em>,\alpha^</em>,\beta^<em>$,使$x^</em>$是原始问题的解，$\alpha^<em>,\beta^</em>$是对偶问题的解，并且</p>
<script type="math/tex; mode=display">
p^*=d^*=L(x^*,\alpha^*,\beta^*) \tag{15}</script></blockquote>
<p><strong>定理3</strong> 考虑原始问题式1~3和对偶问题式10~11，假设<strong>函数$f(x)$和$c_i(x)$是凸函数，$h_j(x)$是仿射函数；并且假设不等式约束$c_i(x)$是严格可行的，即存在$x$，对所有$i$有$c_i(x)&lt;0$</strong><font color="#FF0000"> (slater条件)</font>,则$x^<em>和\alpha^</em>,\beta^<em>$分别是原始问题和对偶问题的解的充分必要条件是$x^</em>,\alpha^<em>,\beta^</em>$满足下面的Karush-Kuhn-Tucker(KKT)条件：</p>
<script type="math/tex; mode=display">\bigtriangledown_xL(x^*,\alpha^*,\beta^*)=0 \tag{16}</script><script type="math/tex; mode=display">\bigtriangledown_{\alpha}L(x^*,\alpha^*,\beta^*)=0 \tag{17}</script><script type="math/tex; mode=display">\bigtriangledown_{\beta}L(x^*,\alpha^*,\beta^*)=0 \tag{18}</script><script type="math/tex; mode=display">\alpha_i^*c_i(x^*)=0,\quad i=1,2,...,k \tag{19}</script><script type="math/tex; mode=display">c_i(x^*)\leq0,\quad i=1,2,...,k \tag{20}</script><script type="math/tex; mode=display">\alpha_i^*\geq0, \quad i=1,2,...,k \tag{21}</script><script type="math/tex; mode=display">h_j(x^*)=0, j=1,2,...,l \tag{22}</script><p>特别指出，式19称为KKT的对偶互补条件。由此条件可知:若$\alpha_i^<em>&gt;0$,则$c_i(x^</em>)=0$</p>
<blockquote>
<p>参考文献：</p>
<p>拉格朗日对偶性：<a href="https://blog.csdn.net/qq_35144795/article/details/98495869" target="_blank" rel="noopener">https://blog.csdn.net/qq_35144795/article/details/98495869</a> \<br>李航《统计学习方法》</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/18/%E6%96%B9%E5%B7%AE-%E5%8D%8F%E6%96%B9%E5%B7%AE-%E6%9C%9F%E6%9C%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/%E6%96%B9%E5%B7%AE-%E5%8D%8F%E6%96%B9%E5%B7%AE-%E6%9C%9F%E6%9C%9B/" class="post-title-link" itemprop="url">方差-协方差-期望</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 21:41:36" itemprop="dateCreated datePublished" datetime="2020-06-18T21:41:36+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-25 23:39:32" itemprop="dateModified" datetime="2019-08-25T23:39:32+08:00">2019-08-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-方差"><a href="#1-方差" class="headerlink" title="1.方差"></a>1.方差</h2><p>对随机变量$X$，若存在$\mathbb{E}\left[(X-\mathbb{E}[X])^{2}\right]$,则称它为$X$的方差，记作$Var[X]$.</p>
<p>$X$的标准差为方差的开平方。即：</p>
<script type="math/tex; mode=display">
\begin{aligned} \operatorname{Var}[X] &=\mathbb{E}\left[(X-\mathbb{E}[X])^{2}\right] \\ \sigma &=\sqrt{\operatorname{Var}[X]} \end{aligned}</script><p>根据定义可知：</p>
<script type="math/tex; mode=display">
\begin{aligned}\operatorname{Var}[X]&=\mathbb{E}\left[(X-\mathbb{E}[X])^{2}\right] \\&= \mathbb{E}(X^2-2X\mathbb{E}[X]+(\mathbb{E}[X])^2)\\&=\mathbb{E}[X^2]-2(\mathbb{E}[X])^2+(\mathbb{E}[X])^2\\&=
\mathbb{E}\left[X^{2}\right]-(\mathbb{E}[X])^{2} \quad (协方差推导中用到)
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
 {\operatorname{Var}[f(X)]=\mathbb{E}\left[(f(X)-\mathbb{E}[f(X)])^{2}\right]}\end{aligned}</script><p>方差的性质：</p>
<ul>
<li>常数的方差恒为0</li>
<li>对常数C，有$Var[CX]=C^2Var[X]$</li>
<li>对两个随机变量$X,Y$,有：$\operatorname{Var}[X+Y]=\operatorname{Var}[X]+\operatorname{Var}[Y]+2 \mathbb{E}[(X-\mathbb{E}[X])(Y-\mathbb{E}[Y])]$，当$X,Y$相互独立时，有$\operatorname{Var}[X+Y]=\operatorname{Var}[X]+\operatorname{Var}[Y]$。</li>
<li>$Var[X]=0$的充要条件是$X$以概率1取常数</li>
</ul>
<h2 id="2-协方差与相关系数"><a href="#2-协方差与相关系数" class="headerlink" title="2.协方差与相关系数"></a>2.协方差与相关系数</h2><p>协方差：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \operatorname{Cov}[X, Y]&=\mathbb{E}[(X-\mathbb{E}[X])(Y-\mathbb{E}[Y])] \\
    &=\mathbb{E}[XY-X\mathbb{E}[Y]-Y\mathbb{E}[X]+\mathbb{E}[X]\mathbb{E}[Y]] \\
    &=\mathbb{E}[XY]-2\mathbb{E}[X]\mathbb{E}[Y]+\mathbb{E}[X]\mathbb{E}[Y]\\
    &=\mathbb{E}[XY]-\mathbb{E}[X]\mathbb{E}[Y]  \quad(协方差推导中用到)
\end{aligned}</script><p>相关系数：</p>
<script type="math/tex; mode=display">
\rho_{X Y}=\frac{\operatorname{Cov}[X, Y]}{\sqrt{\operatorname{Var}[X]} \sqrt{\operatorname{Var}[Y]}}</script><p>是随机变量$X,Y$的相关系数，是协方差的归一化</p>
<p>由定义可知：</p>
<script type="math/tex; mode=display">
\begin{array}{c}{\operatorname{Cov}[X, Y]=\operatorname{Cov}[Y, X]} \\ {\operatorname{Cov}[X, X]=\operatorname{Var}[X]} \\ {\operatorname{Var}[X+Y]=\operatorname{Var}[X]+\operatorname{Var}[Y]+2 \operatorname{Cov}[X, Y]}\end{array}</script><p>协方差的性质：</p>
<script type="math/tex; mode=display">
\begin{array}{l}    
\circ \operatorname{Cov}[a X, b Y]=a b \operatorname{Cov}[X, Y]
\end{array}a,b为常数</script><script type="math/tex; mode=display">
\begin{array}{l}{\circ \operatorname{Cov}\left[X_{1}+X_{2}, Y\right]=\operatorname{Cov}\left[X_{1}, Y\right]+\operatorname{Cov}\left[X_{2}, Y\right]} \\ {\circ \operatorname{Cov}[f(X), g(Y)]=\mathbb{E}[(f(X)-\mathbb{E}[f(X)])(g(Y)-\mathbb{E}[g(Y)])]} \\ {\circ[f(X), g(Y)]=\frac{\operatorname{Cov}[f(X), g(Y)]}{\sqrt{\operatorname{Var}[f(X)]} \sqrt{\operatorname{Var}[g(Y)]}}}\end{array}</script><p>相关系数的物理意义：考虑以随机变量$X$的线性函数$a+bX$来近似表示$Y$。以均方误差:</p>
<script type="math/tex; mode=display">
e=\mathbb{E}\left[(Y-(a+b X))^{2}\right]=\mathbb{E}\left[Y^{2}\right]+b^{2} \mathbb{E}\left[X^{2}\right]+a^{2}-2 b \mathbb{E}[X Y]+2 a b \mathbb{E}[X]-2 a \mathbb{E}[Y]</script><p>来衡量以$a+bX$近似表达$Y$的好坏程度。$e$越小表示近似程度越高。</p>
<p>为求得最好的近似，则对$a,b$分别取偏导数，得到：</p>
<script type="math/tex; mode=display">
\frac{\partial e}{\partial a}=a+b\mathbb{E}[X]-\mathbb{E}[Y]=0 \Rightarrow a=\mathbb{E}[Y]-b\mathbb{E}[X] \tag{1}</script><script type="math/tex; mode=display">
\frac{\partial e}{\partial b}=b\mathbb{E}[X^2]-\mathbb{E}[XY]+a\mathbb{E}[X]=0 \tag{2}</script><p>将$a=\mathbb{E}[Y]-b\mathbb{E}[X]$代入(2)得：</p>
<script type="math/tex; mode=display">
b\mathbb{E}[X^2]-\mathbb{E}[XY]+\mathbb{E}[X]\mathbb{E}[Y]-b(\mathbb{E}[X])^2=0</script><script type="math/tex; mode=display">
\Rightarrow b=\frac{\mathbb{E}[XY]-\mathbb{E}[X]\mathbb{E}[Y]}{\mathbb{E}[X^2]-(\mathbb{E}[X])^2} = \frac{\operatorname{Cov}[X, Y]}{\operatorname{Var}[X]}</script><p>所以，</p>
<script type="math/tex; mode=display">
\begin{array}{c}{a_{0}=\mathbb{E}[Y]-b_{0} \mathbb{E}[X]=\mathbb{E}[Y]-\mathbb{E}[X] \frac{\operatorname{Cov}[X, Y]}{\operatorname{Var}[X]}} \\ {b_{0}=\frac{\operatorname{Cov}[X, Y]}{\operatorname{Var}[X]}} \end{array}</script><script type="math/tex; mode=display">
\begin{aligned}
    min(e) &=\mathbb{E}\left[\left(Y-\left(a_{0}+b_{0} X\right)\right)^{2}\right] \\
    &=\mathbb{E}\left[Y^{2}\right]+b_0^{2} \mathbb{E}\left[X^{2}\right]+a_0^{2}-2 b_0 \mathbb{E}[X Y]+2 a_0 b_0 \mathbb{E}[X]-2 a_0 \mathbb{E}[Y] \\
    &=\mathbb{E}[Y^2]+b_0^2\mathbb{E}[X^2]+(\mathbb{E}[Y])^2-2b_0\mathbb{E}[X]\mathbb{E}[Y]+b_0^2(\mathbb{E}[X])^2 - 2b_0\mathbb{E}[XY]+2b_0\mathbb{E}[X]\mathbb{E}[Y]-2b_0^2(\mathbb{E}[X])^2- 2(\mathbb{E}[Y])^2+2b_0\mathbb{E}[X]\mathbb{E}[Y] \\
    &=b_0^2[\mathbb{E}[X^2]-(\mathbb{E}[X])^2]+[\mathbb{E}[Y^2]-(\mathbb{E}[Y])^2]-2b_0(\mathbb{E}[XY]-\mathbb{E}[X]\mathbb{E}[Y])\\
    &=b_0^2Var[X]+Var[Y]-2b_0Cov(X,Y) \quad (将b_0=\frac{\operatorname{Cov}[X, Y]}{\operatorname{Var}[X]}) \\
    &=Var[Y] - \frac{\operatorname{Cov}^2[X, Y]}{\operatorname{Var}[X]}) \\
    &=Var[Y](1-\frac{\operatorname{Cov}^2[X, Y]}{\operatorname{Var}[X]\operatorname{Var}[Y]}) \\
    &=\left(1-\rho_{X Y}^{2}\right) \operatorname{Var}[Y]
\end{aligned}</script><p>因此有以下定理：</p>
<ul>
<li>$|\rho_{XY}|\leq 1$</li>
<li>$|\rho_{XY}|= 1$的充要条件是：存在常数$a,b$使得$P{Y=a+bX}=1$.</li>
<li>当$\rho<em>{XY}$较大时， $e$较小，意味着随机变量$X$和$Y$联系较紧密。于是$\rho</em>{XY}$是一个表征 $X,Y$ 之间线性关系紧密程度的量.</li>
<li>当$\rho_{XY}=0$ 时，称 $X$和 $Y$不相关.<ul>
<li>不相关是就线性关系来讲的，而相互独立是一般关系而言的</li>
<li>相互独立一定不相关；不相关则未必独立。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/18/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC/" class="post-title-link" itemprop="url">反向传播算法推导</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 21:41:36" itemprop="dateCreated datePublished" datetime="2020-06-18T21:41:36+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-25 23:39:19" itemprop="dateModified" datetime="2019-08-25T23:39:19+08:00">2019-08-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="反向传播算法详细推导过程"><a href="#反向传播算法详细推导过程" class="headerlink" title="反向传播算法详细推导过程"></a><strong>反向传播算法详细推导过程</strong></h1><h2 id="1-前向传播"><a href="#1-前向传播" class="headerlink" title="1. 前向传播"></a><strong>1. 前向传播</strong></h2><p><img src="./images/feedfoward.jpg" alt></p>
<p>假设$X$为$N\times m$的矩阵（其中，$N$为样本个数（batch size），$m$为特征维数）</p>
<p>$h<em>1$与$Z_1$的维数为$m_1 \rightarrow W_1$为$m\times m_1$的矩阵，$b_1 \in \mathbb{R}^{m_1},\$<br>$h_2$与$Z_2$的维数为$m_2 \rightarrow W_2$为$m_1\times m_2$的矩阵，$b_2 \in \mathbb{R}^{m_2},\$<br>${\vdots}\$<br>$h_L$与$Z_L$的维数为$m_L \rightarrow W_L$为$m</em>{L-1}\times m_L$的矩阵，$b_L \in \mathbb{R}^{m_L}$</p>
<h3 id="前向算法："><a href="#前向算法：" class="headerlink" title="前向算法："></a>前向算法：</h3><script type="math/tex; mode=display">
\begin{array}{l}{h_{1}=x W_{1}+\tilde{b}_{1}, Z_{1}=f_{1}\left(h_{1}\right), \tilde{b}_{1}}为b_1^T沿着行方向扩展成N行 \\ {h_{2}=Z_{1} W_{2}+\tilde{b}_{2}, Z_{2}=f_{2}\left(h_{2}\right)} \\ {\vdots} \\ {h_{L}=Z_{L-1} W_{L}+\tilde{b}_{L}, Z_{L}=f_{L}\left(h_{L}\right)} \\ {\text { out }=Z_{L} W_{L+1}+\tilde{b}_{L+1}}\end{array}</script><p>假设输出为$n$维，则$out$为大小为$N\times n$的矩阵，根据MSE或CE准则可以求得$\frac{\partial J}{\partial out}$，对于回归问题与分类问题，$\frac{\partial J}{\partial out}$的求解方法如下：</p>
<table align="center">
    <tr>
        <td><center><img height="200" src="./images/回归问题.jpg">回归问题</center></td>
        <td><center><img height="200" src="./images/分类问题.jpg">分类问题</center></td>
    </tr>
</table>

<ul>
<li>对于回归问题，对out直接计算损失，损失函数为MSE。 损失：$J=\frac{1}{2N}\sum_{i=1}^{N}||y_i-\tilde{y_i}||^2$<script type="math/tex; mode=display">
\begin{aligned}
    \frac{\partial J}{\partial y_i}&=\frac{1}{2N}\sum_{i=1}^{N}(y_i-\tilde{y_i})\times 2 \\
    &=\frac{1}{N}\sum_{i=1}^{N}(y_i-\tilde{y_i})
\end{aligned}</script></li>
<li>对于分类问题，out后接softmax进行分类，然后使用CE(cross entropy)计算loss.$S<em>k=\frac{e^{y_k}}{\sum</em>{i=1}^{n}e^{y_i}}$一个样本对应的网络的输出$S(s_1,s_2,…,s_n)$是一个概率分布，而这个样本的标注$\tilde{S}$一般为$(0,0,…,1,0,0,…,0)$，也可以看做一个概率分布（硬分布）。cross entropy可以看成是$S$与$\tilde{S}$之间的KL距离：<script type="math/tex; mode=display">D(\tilde{S}||S)=\Sigma\tilde{S}\log\frac{\tilde{S}}{S}</script><ul>
<li>假设$\tilde{S}=(0,0,…,1,0,0,…,0)$，其中1为第$k$个元素(索引从0开始)，令$S=(s<em>0,s_1,…,s_k,…,s</em>{n-1})$.<br>损失：<script type="math/tex; mode=display">
\begin{aligned}
  J=D(\tilde{S}||S)&=1\times \log\frac{1}{s_k}\\&=-\log s_k \quad(CE损失函数,可看做目标类别概率最大)\\
  &=-\log\frac{e^{y_k}}{\sum_{i=0}^{n-1}e^{y_i}}
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
 &\frac{\partial J}{\partial y_m}=\frac{\partial J}{\partial y_m}(\log \sum_{i=0}^{n-1}e^{y_i}-y_k)=\frac{e^{y_m}}{\sum_{i=0}^{n-1}e^{y_i}}-\delta(m=k)=s_m-\delta(m=k) \\
&写成向量形式为:\frac{\partial J}{\partial y}=S-\tilde{S}
\end{aligned}</script></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>KL距离（相对熵）</strong>：是Kullback-Leibler Divergence的简称，也叫相对熵(Relative Entropy).它衡量的是相同事件空间里的两个概率分布的差异情况。其物理意义是：在相同事件空间里，概率分布$P(x)$对应的每个事件，若用概率分布$Q(x)$编码时，平均每个基本事件(符号)编码长度增加了多少比特。我们用$D(P||Q)$表示KL距离，计算公式如下：</p>
<script type="math/tex; mode=display">
D(P||Q)=\sum_{x\in X}P(x)\log\frac{P(x)}{Q(x)}</script><p>当两个概率分布完全相同时，即$P(X)=Q(X)$,其相对熵为0.</p>
<h2 id="2-反向传播"><a href="#2-反向传播" class="headerlink" title="2.反向传播"></a><strong>2.反向传播</strong></h2><p>$\text { out }=Z<em>{L} W</em>{L+1}+\tilde{b}<em>{L+1}$，为了便于详细说明反向传播算法，假设$Z_L$为$2\times 3$的向量，$W</em>{L+1}$为$3\times 2$的向量：</p>
<script type="math/tex; mode=display">
\begin{array}{l}{Z_{L}=\left(\begin{array}{ccc}{z_{11}} & {z_{12}} & {z_{13}} \\ {z_{21}} & {z_{22}} & {z_{23}}\end{array}\right)_{2 \times 3}, W_{L+1}=\left(\begin{array}{cc}{w_{11}} & {w_{12}} \\ {w_{21}} & {w_{22}} \\ {w_{31}} & {w_{32}}\end{array}\right)_{3 \times 2} \tilde{b}_{L+1}=\left(\begin{array}{cc}{b_{1}} & {b_{2}} \\ {b_{1}} & {b_{2}}\end{array}\right)_{2 \times 2}, \text { out }=\left(\begin{array}{cc}{o_{11}} & {o_{12}} \\ {o_{21}} & {o_{22}}\end{array}\right)} \\ \Rightarrow  {Z_{L}W_{L+1}+\tilde{b}_{L+1}=\left(\begin{array}{cc}{z_{11} w_{11}+z_{12} w_{21}+z_{13} w_{31}+b_1} & {z_{11} w_{12}+z_{12} w_{22}+z_{13} w_{32}+b_2} \\ {z_{21} w_{11}+z_{22} w_{21}+z_{23} w_{31}+b_1} & {z_{21} w_{12}+z_{22} w_{22}+z_{23} w_{32}+b_2}\end{array}\right)=\text{out}.}\end{array}</script><p>所以，</p>
<script type="math/tex; mode=display">
\begin{array}{l}{o_{11}=z_{11} w_{11}+z_{12} w_{21}+z_{13} w_{31}+b_{1}} \\ {o_{12}=z_{11} w_{12}+z_{12} w_{22}+z_{13} w_{32}+b_{2}} \\ {o_{21}=z_{21} w_{11}+z_{22} w_{21}+z_{23} w_{31}+b_{1}} \\ {o_{22}=z_{21} w_{12}+z_{22} w_{22}+z_{23} w_{32}+b_{2}}\end{array}</script><h4 id="1-损失-J-对-W-的导数："><a href="#1-损失-J-对-W-的导数：" class="headerlink" title="1) 损失$J$对$W$的导数："></a><strong>1) 损失$J$对$W$的导数：</strong></h4><script type="math/tex; mode=display">
\begin{aligned} \frac{\partial J}{\partial w_{11}} &=\frac{\partial J}{\partial o_{11}} z_{11}+\frac{\partial J}{\partial o_{21}} z_{21}, \frac{\partial J}{\partial w_{12}}=\frac{\partial J}{\partial o_{12}} z_{11}+\frac{\partial J}{\partial o_{22}} z_{21} \\ \frac{\partial J}{\partial w_{21}} &=\frac{\partial J}{\partial o_{11}} z_{12}+\frac{\partial J}{\partial o_{21}} z_{22}, \frac{\partial J}{\partial w_{22}}=\frac{\partial J}{\partial o_{12}} z_{12}+\frac{\partial J}{\partial o_{22}} z_{22} \\ \frac{\partial J}{\partial w_{31}} &=\frac{\partial J}{\partial o_{11}} z_{13}+\frac{\partial J}{\partial o_{21}} z_{23}, \frac{\partial J}{\partial w_{32}}=\frac{\partial J}{\partial o_{12}} z_{13}+\frac{\partial J}{\partial o_{22}} z_{23} \end{aligned}</script><script type="math/tex; mode=display">
\Rightarrow
\left(\begin{array}{cc}{\frac{\partial J}{\partial w_{11}}} & {\frac{\partial J}{\partial w_{12}}} \\ {\frac{\partial J}{\partial w_{21}}} & {\frac{\partial J}{\partial w_{22}}} \\ {\frac{\partial J}{\partial w_{31}}} & {\frac{\partial J}{\partial w_{32}}}\end{array}\right)=\left(\begin{array}{cc}{z_{11}} & {z_{21}} \\ {z_{12}} & {z_{22}} \\ {z_{13}} & {z_{23}}\end{array}\right)\left(\begin{array}{cc}{\frac{\partial J}{\partial o_{11}}} & {\frac{\partial J}{\partial o_{12}}} \\ {\frac{\partial J}{\partial o_{21}}} & {\frac{\partial J}{\partial o_{22}}}\end{array}\right)</script><p>即，$\frac{\partial J}{\partial W_{L+1}}=Z_L^T\frac{\partial J}{\partial out}$</p>
</blockquote>
<h4 id="2-损失对偏置b的导数等于将-frac-partial-J-partial-out-的每一列加起来："><a href="#2-损失对偏置b的导数等于将-frac-partial-J-partial-out-的每一列加起来：" class="headerlink" title="2) 损失对偏置b的导数等于将$\frac{\partial J}{\partial out}$的每一列加起来："></a><strong>2) 损失对偏置b的导数等于将$\frac{\partial J}{\partial out}$的每一列加起来：</strong></h4><script type="math/tex; mode=display">
\left\{\begin{array}{l}{\frac{\partial J}{\partial b_{1}}=\frac{\partial J}{\partial o_{11}}+\frac{\partial J}{\partial o_{21}}} \\ {\frac{\partial J}{\partial b_{2}}=\frac{\partial J}{\partial o_{12}}+\frac{\partial J}{\partial o_{22}}}\end{array} \Rightarrow\left(\frac{\partial J}{\partial b_{L+1}}\right)^{T}=\left(\frac{\partial J}{\partial b_{1}} \quad \frac{\partial J}{\partial b_{2}}\right)=\left(\frac{\partial J}{\partial o_{11}}+\frac{\partial J}{\partial o_{21}} \quad \frac{\partial J}{\partial o_{12}}+\frac{\partial J}{\partial o_{22}}\right)\right.</script><h4 id="3-损失-J-对-Z-的导数："><a href="#3-损失-J-对-Z-的导数：" class="headerlink" title="3) 损失$J$对$Z$的导数："></a><strong>3) 损失$J$对$Z$的导数：</strong></h4><script type="math/tex; mode=display">
\begin{aligned} \frac{\partial J}{\partial z_{11}} &=\frac{\partial J}{\partial o_{11}} w_{11}+\frac{\partial J}{\partial o_{12}} w_{12} ; \frac{\partial J}{\partial z_{12}}=\frac{\partial J}{\partial o_{11}} w_{21}+\frac{\partial J}{\partial o_{12}} w_{22} ; \frac{\partial J}{\partial z_{13}}=\frac{\partial J}{\partial o_{11}} w_{31}+\frac{\partial J}{\partial o_{12}} w_{32} \\ \frac{\partial J}{\partial z_{21}} &=\frac{\partial J}{\partial o_{21}} w_{11}+\frac{\partial J}{\partial o_{22}} w_{12} ; \frac{\partial J}{\partial z_{22}}=\frac{\partial J}{\partial o_{21}} w_{21}+\frac{\partial J}{\partial o_{12}} w_{22} ; \frac{\partial J}{\partial z_{23}}=\frac{\partial J}{\partial o_{21}} w_{31}+\frac{\partial J}{\partial o_{22}} w_{32} \end{aligned}</script><p>即，</p>
<script type="math/tex; mode=display">
\left(\begin{array}{ccc}{\frac{\partial J}{\partial z_{11}}} & {\frac{\partial J}{\partial z_{12}}} & {\frac{\partial J}{\partial z_{13}}} \\ {\frac{\partial J}{\partial z_{21}}} & {\frac{\partial J}{\partial z_{22}}} & {\frac{\partial J}{\partial z_{23}}}\end{array}\right)=\left(\begin{array}{cc}{\frac{\partial J}{\partial o_{11}}} & {\frac{\partial J}{\partial o_{12}}} \\ {\frac{\partial J}{\partial \theta_{21}}} & {\frac{\partial J}{\partial o_{22}}}\end{array}\right)\left(\begin{array}{ccc}{w_{11}} & {w_{21}} & {w_{31}} \\ {w_{12}} & {w_{22}} & {w_{32}}\end{array}\right)</script><p>$\Rightarrow \frac{\partial J}{\partial Z<em>{L}}=\frac{\partial J}{\partial out}W</em>{L+1}^T$</p>
<h4 id="4-损失-J-对-h-的导数："><a href="#4-损失-J-对-h-的导数：" class="headerlink" title="4) 损失$J$对$h$的导数："></a><strong>4) 损失$J$对$h$的导数：</strong></h4><script type="math/tex; mode=display">Z_L = f_L(h_L)</script><ul>
<li>$f_L$为sigmoid时，$Z_L=\frac{1}{1+e^{-h_L}}$.<script type="math/tex; mode=display">
\begin{array}{l}{\frac{\partial J}{\partial h_{L}}=\frac{\partial J}{\partial Z_{L}} \frac{d z_{L}}{d h_{L}}=\frac{\partial J}{\partial Z_{L}} \frac{e^{-h L}}{\left(1+e^{-h_{L}}\right)^{2}}=\frac{\partial J}{\partial Z_{L}} \frac{1}{1+e^{-h_{L}}} \frac{e^{-h_{L}}}{1+e^{-h_{L}}}} \\ {=\frac{\partial J}{\partial Z_{L}} Z_{L}\left(1-Z_{L}\right)}\end{array}</script></li>
<li>$f<em>L$为tanh时，${Z</em>{L}=\frac{e^{h<em>{L}}-e^{-h</em>{L}}}{e^{h<em>{L}}+e^{-h</em>{L}}}}$.<script type="math/tex; mode=display">
\begin{array}{l} {\frac{\partial J}{\partial h_{L}}=\frac{\partial J}{\partial Z_{L}} \frac{d Z_{L}}{d h_{L}}=\frac{\partial J}{\partial Z_{L}} \frac{4}{\left(e^{h_{L}}+e^{-h_{L}}\right)^{2}}=\frac{\partial J}{\partial Z_{L}}\left[1-\left(\frac{e^{h_{L}}-e^{-h_{L}}}{e^{h_{L}}+e^{-h_{L}}}\right)^{2}\right]} \\ {=\frac{\partial J}{\partial z_{L}}\left[1-z_{L}^{2}\right]}\end{array}</script></li>
<li>$f_L$为relu时，$Z_L=relu(h_L)=\left{\begin{matrix}<br>0,&amp;h_L\leq 0 \<br>h_L,&amp;h_L &gt; 0<br>\end{matrix}\right.$.<script type="math/tex; mode=display">
\begin{array}{l}
  \frac{\partial J}{\partial h_L}=\frac{\partial J}{\partial Z_L}\frac{\partial Z_L}{\partial h_L}=\left\{\begin{matrix}
0,&h_L\leq 0 \\ 
\frac{\partial J}{\partial Z_L},&h_L > 0 
\end{matrix}\right.
\end{array}</script></li>
</ul>
<h2 id="3-梯度更新"><a href="#3-梯度更新" class="headerlink" title="3. 梯度更新"></a><strong>3. 梯度更新</strong></h2><p>对于不同算法 ，梯度更新方式如下：</p>
<script type="math/tex; mode=display">
\frac{\partial J}{\partial out} \Rightarrow \left \{\begin{matrix}
    \frac{\partial J}{\partial W_{L+1}}=Z_L^T\frac{\partial J}{\partial out} \\
    \frac{\partial J}{\partial Z_{L}}=\frac{\partial J}{\partial out}W_{L+1}^T \\
    \left(\frac{\partial J}{\partial b}\right)^{T}=SumCol(\frac{\partial J}{\partial out}) \\
    W_{L+1}^{t+1} = W_{L+1}^t-\eta \frac{\partial J}{\partial W_{L+1}} \\
    b_{L+1}^{t+1} = b_{L+1}^t-\eta \frac{\partial J}{\partial b_{L+1}}
\end{matrix} \right. \Rightarrow \frac{\partial J}{\partial h_L}=\frac{\partial J}{\partial Z_L}\frac{\partial Z_L}{\partial h_L} \Rightarrow \left \{\begin{matrix} 
    \frac{\partial J}{\partial W_{L}}=Z_{L-1}^T\frac{\partial J}{\partial h_L} \\
    \frac{\partial J}{\partial Z_{L-1}}=\frac{\partial J}{\partial h_L}W_{L}^T \\
    \vdots \\
    \vdots 
\end{matrix}\right. \Rightarrow \cdots</script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/18/svd%E5%88%86%E8%A7%A3%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/svd%E5%88%86%E8%A7%A3%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">svd分解推导过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 21:41:36" itemprop="dateCreated datePublished" datetime="2020-06-18T21:41:36+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-08-04 20:49:32" itemprop="dateModified" datetime="2019-08-04T20:49:32+08:00">2019-08-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="SVD奇异值分解逐步推导"><a href="#SVD奇异值分解逐步推导" class="headerlink" title="SVD奇异值分解逐步推导"></a>SVD奇异值分解逐步推导</h2><h3 id="1-回顾特征值和特征向量"><a href="#1-回顾特征值和特征向量" class="headerlink" title="1. 回顾特征值和特征向量"></a>1. 回顾特征值和特征向量</h3><p>首先回顾下特征值和特征向量的定义：</p>
<script type="math/tex; mode=display">
Ax=\lambda x</script><p>其中，A是一个$n\times n$的矩阵，$x$是一个$n$维向量，则$\lambda$是矩阵A的一个特征值，而$x$是矩阵A的特征值$\lambda$对应的特征向量。</p>
<p>求出特征值和特征向量有什么好处呢？就是我们可以将矩阵A特征分解。如果我们求出了矩阵A的n个特征值$\lambda _1\leq \lambda_2\leq … \leq\lambda_n$，以及这$n$个特征值所对应的特征向量$w_1, w_2, …, w_n$,那么矩阵A就可以用以下的特征分解表示：</p>
<script type="math/tex; mode=display">
W^{-1}AW=\Lambda \Leftrightarrow A=W\Lambda W^{-1}</script><p>其中，$W$是这$n$个特征向量所组成的$n\times n$维矩阵，而$\Lambda$是将这$n$个特征值作为主对角线的$n\times n$维矩阵。一般情况下，我们会把$W$的这$n$个特征向量标准化，即满足$||w_i||_2=1$，或者$w_i^Tw_i=1$,此时$W$的$n$个特征向量为标准正交基，满足$W^TW=I$，即$W^T=W^{-1}$,也就是说$W$为酉矩阵。这样我们的特征分解表达式可以写成：</p>
<script type="math/tex; mode=display">
A=W\Lambda W^T</script><blockquote>
<p>题外延伸———矩阵压缩：</p>
<p>设$W=(w_1, w_2, w_3,…,w_n)$，则:</p>
<script type="math/tex; mode=display">W^T=\begin{pmatrix}
 w_1^T\\ 
 w_2^T\\ 
 w_3^T\\ 
... \\
w_n^T
\end{pmatrix}</script><p>那么:</p>
<script type="math/tex; mode=display">
A=(w_1, w_2, w_3,...,w_n)\begin{pmatrix}
    \lambda_1&&&\\
    &\lambda_2&&\\
    &&\lambda_3&\\
    &&&...\\
    &&&&\lambda_n
\end{pmatrix}\begin{pmatrix}
 w_1^T\\ 
 w_2^T\\ 
 w_3^T\\ 
... \\
w_n^T
\end{pmatrix}
\\
=\lambda_1w_1w_1^T+\lambda_2w_2w_2^T+\lambda_3w_3w_3^T+...+\lambda_nw_nw_n^T</script><p>假设A为$n\times n$维矩阵，如果正常表示矩阵A共需使用$n^2$个元素，如果将取得的特征值$\lambda_1,\lambda_2,\lambda_3,…,\lambda_n$按从大到小排序，即$\lambda_1\geq\lambda_2\geq\lambda_3\geq…\geq\lambda_n$，则将A的压缩表示为$\lambda_1w_1w_1^T$，即只需要$n+1$个元素。</p>
</blockquote>
<p>注意到要进行特征分解，矩阵A必须为方阵。</p>
<p>那么如果A不是方阵，即行和列不相同时，我们还可以对矩阵进行分解吗？答案是可以，此时我们的SVD登场了。</p>
<h3 id="2-SVD推导"><a href="#2-SVD推导" class="headerlink" title="2. SVD推导"></a>2. SVD推导</h3><h4 id="Step1：矩阵分解"><a href="#Step1：矩阵分解" class="headerlink" title="Step1：矩阵分解"></a>Step1：矩阵分解</h4><p>假如$A$为$m\times n$维矩阵，则$A^TA$为对称正定矩阵。</p>
<blockquote>
<p>证明：1)对称性：$(A^TA)^T=A^TA\Rightarrow 对称性$<br>2)正定性： $x^TA^TAx=(Ax)^T(Ax)\geq 0\Rightarrow正定性$</p>
</blockquote>
<p>对于矩阵A，有$(A^TA)v_i=\lambda _iv_i$，其中$\lambda_i$为特征值，$v_i$为特征向量。假定$(v_i, v_j)$是一组正交基，那么有$v_i^T\cdot v_j=0$，那么：</p>
<script type="math/tex; mode=display">
(Av_i, Av_j)=(Av_i)^T\cdot Av_j=v_i^TA^TAv_j=v_i^T\lambda_jv_j=\lambda_jv_i^Tv_j=0</script><p>因此，$Av_i,Av_j$也是一组正交基，根据上述公式可以推导出$(Av_i, Av_i)=\lambda_iv_i^Tv_i=\lambda_i$,从而可以得到：</p>
<script type="math/tex; mode=display">
|Av_i|^2=\lambda_i</script><script type="math/tex; mode=display">
|Av_i|=\sqrt{\lambda_i}</script><p>根据上述公式，有$\frac{Av_i}{|Av_i|}=\frac{1}{\sqrt{\lambda_i}}Av_i$，令$\frac{1}{\sqrt{\lambda_i}}Av_i=u_i$，可得：</p>
<script type="math/tex; mode=display">
Av_i=\sqrt{\lambda_i}u_i=\delta_i u_i</script><p>其中，$\delta_i=\sqrt{\lambda_i}$，进一步推导：</p>
<script type="math/tex; mode=display">
AV=A(v_1,v_2,...,v_n)=(Av_1,Av_2,...,Av_n)=(\delta_1u_1,\delta_2u_2,...,\delta_nu_n)=U\Sigma</script><p>从而得出：</p>
<script type="math/tex; mode=display">A=U\Sigma V^T</script><h4 id="Step2-矩阵计算"><a href="#Step2-矩阵计算" class="headerlink" title="Step2:矩阵计算"></a>Step2:矩阵计算</h4><p>得到矩阵A的表示后，我们应该如何计算向量$U$和$V$呢？继续往下面分析：</p>
<p>首先计算出A的转置$A^T$：$A^T=V\Sigma ^TU^T$</p>
<script type="math/tex; mode=display">
A^TA=V\Sigma^TU^TU\Sigma V^T=V\Sigma^2V^T</script><p>利用上式可以得到，$A^TAv_i=\lambda_iv_i$，只需要求出$A^TA$的特征向量即可得到$V$.</p>
<p>同理可得$AA^T$的值：</p>
<script type="math/tex; mode=display">
AA^T=U\Sigma V^TV\Sigma^TU^T=U\Sigma^2U^T</script><p>可以得到$AA^Tu_i=\lambda_iu_i$，只需要求出$AA^T$的特征向量即可得到$U$.</p>
<blockquote>
<p>题外延伸——-矩阵(图像)压缩：</p>
<p>一个$m\times n$的矩阵A经SVD分解后，可以写成如下形式：</p>
<script type="math/tex; mode=display">
A_{m\times n}=U_{m\times m}\Sigma V^T_{n\times n}=(u_1,u_2,...,u_m)\begin{pmatrix}
    \lambda_1^{\frac{1}{2}}&&\\
    &\lambda_2^{\frac{1}{2}}&\\
    &&...
\end{pmatrix}\begin{pmatrix}
    v_1^T\\
    v_2^T\\
    ...\\
    v_n^T
\end{pmatrix}\\
=\lambda_1^{\frac{1}{2}}u_1v_1^T+\lambda_2^{\frac{1}{2}}u_2v_2^T+...</script><p>假设A为$m\times n$维矩阵，在没有压缩时表示矩阵A共需要$m\times n$个元素。如果将取得的特征值按从大到小排序，即$\lambda<em>1\geq\lambda_2\geq\lambda_3\geq…\geq\lambda</em>{min{m,n}}$，则A的压缩最小压缩表示为$\lambda_1^{\frac{1}{2}}u_1v_1^T$，即需要$m+n+1$个元素。<br>当压缩储存量为$(m+n+1)\times k$时，误差为</p>
<script type="math/tex; mode=display">
error=\frac{(m+n)\times\sum_{i=1}^{k}\lambda_i}{(m+n)\times\sum_{i=1}^{min(m,n)}\lambda_i}=\frac{\sum_{i=1}^{k}\lambda_i}{\sum_{i=1}^{min(m,n)}\lambda_i}</script></blockquote>
<h3 id="例题讲解"><a href="#例题讲解" class="headerlink" title="例题讲解"></a>例题讲解</h3><p>我们举一个简单的例子讲解矩阵时如何进行奇异值分解的。定义矩阵A为：</p>
<script type="math/tex; mode=display">
A=\begin{pmatrix}
0 &1 \\
1&1\\
1&0  
\end{pmatrix}</script><p>首先求出$A^TA、AA^T$：</p>
<script type="math/tex; mode=display">
A^TA=\begin{pmatrix}
    0&1&1\\
    1&1&0
\end{pmatrix}\begin{pmatrix}
    0&1\\
    1&1\\
    1&0
\end{pmatrix}=\begin{pmatrix}
    2&1\\
    1&2
\end{pmatrix}</script><script type="math/tex; mode=display">
AA^T=\begin{pmatrix}
    0&1\\
    1&1\\
    1&0
\end{pmatrix}\begin{pmatrix}
    0&1&1\\
    1&1&0
\end{pmatrix}=\begin{pmatrix}
    1&1&0\\
    1&2&1\\
    0&1&1
\end{pmatrix}</script><p>进而求出$A^TA$的特征值和特征向量：</p>
<script type="math/tex; mode=display">
\lambda_1=3;v_1=\begin{pmatrix}
    \frac{1}{\sqrt{2}}\\
    \frac{1}{\sqrt{2}}
\end{pmatrix};
\lambda_2=1;v_2=\begin{pmatrix}
    -\frac{1}{\sqrt{2}}\\
    \frac{1}{\sqrt{2}}
\end{pmatrix}</script><p>接着求出$AA^T$的特征值和特征向量：</p>
<script type="math/tex; mode=display">
\lambda_1=3;u_1=\begin{pmatrix}
    \frac{1}{\sqrt{6}}\\
    \frac{2}{\sqrt{6}}\\
    \frac{1}{\sqrt{6}}
\end{pmatrix};
\lambda_2=1;u_2=\begin{pmatrix}
    \frac{1}{\sqrt{2}}\\
    0\\
    -\frac{1}{\sqrt{2}}
\end{pmatrix};\lambda_3=0;u_3=\begin{pmatrix}
    \frac{1}{\sqrt{3}}\\
    -\frac{1}{\sqrt{3}}\\
    \frac{1}{\sqrt{3}}
\end{pmatrix}</script><p>利用$Av_i=\delta_iu_i,i=1,2$求奇异值：</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
    0&1\\
    1&1\\
    1&0
\end{pmatrix}\begin{pmatrix}
    \frac{1}{\sqrt{2}}\\
    \frac{1}{\sqrt{2}}
\end{pmatrix}=\delta_1\begin{pmatrix}
    \frac{1}{\sqrt{6}}\\
    \frac{2}{\sqrt{6}}\\
    \frac{1}{\sqrt{6}}
\end{pmatrix} \Rightarrow\delta_1=\sqrt{3}</script><script type="math/tex; mode=display">
\begin{pmatrix}
    0&1\\
    1&1\\
    1&0
\end{pmatrix}\begin{pmatrix}
    -\frac{1}{\sqrt{2}}\\
    \frac{1}{\sqrt{2}}
\end{pmatrix}=\delta_2\begin{pmatrix}
    \frac{1}{\sqrt{2}}\\
    0\\
    -\frac{1}{\sqrt{2}}
\end{pmatrix} \Rightarrow\delta_2=1</script><p>也可以用$\delta_i=\sqrt{\lambda_i}$直接求出奇异值为$\sqrt{3}$和$1$.</p>
<p>最终得到矩阵A的奇异值分解为：</p>
<script type="math/tex; mode=display">
A=U\Sigma V^T=\begin{pmatrix}
    \frac{1}{\sqrt{6}}  &\frac{1}{\sqrt{2}}  & \frac{1}{\sqrt{3}} \\
    \frac{2}{\sqrt{6}}  &0  & -\frac{1}{\sqrt{3}} \\
    \frac{1}{\sqrt{6}}  &-\frac{1}{\sqrt{2}}  & \frac{1}{\sqrt{3}} 
\end{pmatrix}\begin{pmatrix}
    \sqrt{3}  & 0\\
    0  & 1\\
    0  & 0
\end{pmatrix}\begin{pmatrix}
    \frac{1}{\sqrt{2}}  & \frac{1}{\sqrt{2}} \\
    -\frac{1}{\sqrt{2}}  & \frac{1}{\sqrt{2}}
\end{pmatrix}</script><h3 id="SVD的一些性质"><a href="#SVD的一些性质" class="headerlink" title="SVD的一些性质"></a>SVD的一些性质</h3><p>对于奇异值，他跟我们特征分解中的特征值类似，在奇艺置矩阵中也是按照从大到小排列，而且奇异值的减少特别快，在很多情况下，前10\%甚至1\%的奇异值就占了全部的奇异值之和的99\%以上的比例。也就是说，我们也可以用最大的k个奇异值和对应的左右奇异向量来近似描述矩阵(与前面描述的题外延伸之矩阵压缩类似)，由于这个重要的性质，SVD也可以用于PCA降维，来做数据压缩和去噪，也可以用于推荐算法，将用户和喜好对应的矩阵做特征分解，进而得到隐含的用户需要来做推荐。同时也可以用于NLP中的算法，比如潜在语义索引（LSI）。</p>
<blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/29846048" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29846048</a> </p>
<p>参考：<a href="https://www.csuldw.com/2017/03/09/2017-03-09-svd/" target="_blank" rel="noopener">https://www.csuldw.com/2017/03/09/2017-03-09-svd/</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/18/RNN%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E3%80%81%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/RNN%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E3%80%81%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">RNN前向传播、反向传播与并行计算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 21:41:36" itemprop="dateCreated datePublished" datetime="2020-06-18T21:41:36+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-13 16:01:51" itemprop="dateModified" datetime="2019-09-13T16:01:51+08:00">2019-09-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RNN前向传播、反向传播与并行计算-非常详细"><a href="#RNN前向传播、反向传播与并行计算-非常详细" class="headerlink" title="RNN前向传播、反向传播与并行计算(非常详细)"></a>RNN前向传播、反向传播与并行计算(非常详细)</h1><h2 id="1-RNN前向传播"><a href="#1-RNN前向传播" class="headerlink" title="1. RNN前向传播"></a>1. RNN前向传播</h2><p>在介绍RNN之前，首先比较一下RNN与CNN的区别：</p>
<ul>
<li>RNN是一类用于处理序列数据的神经网络，CNN是一类用于处理网格化数据(如一幅图像)的神经网络。</li>
<li>RNN可以扩展到更长的序列，大多数RNN也能处理可变长度的序列。CNN可以很容易地扩展到具有很大宽度和高度的图像，并且可以处理可变大小的图像。</li>
</ul>
<p><img src="./images/RNN-前向.jpg" alt="RNN示意图"><br>RNN的前向传播如图所示，其中$f(x)$代表激活函数，输出的label可以使用one-hot形式。图中所有的$U、W、V、b_1、b_2$全部相同，类似于CNN中的权值共享。CNN通过权值共享可以处理任意大小的图片，RNN通过权值共享，可以处理任意序列长度的语音、句子。</p>
<p>损失函数：</p>
<script type="math/tex; mode=display">
J=\sum_{i=1}^{t}||o_i-\hat{o}_i||^2=J_1+J_2+...+J_t（J_i为MSE损失或CE损失）</script><h2 id="2-RNN反向传播"><a href="#2-RNN反向传播" class="headerlink" title="2.RNN反向传播"></a>2.RNN反向传播</h2><p>在介绍RNN反向传播之前，先回顾一下基本神经元的反向传播算法：<br><img src="./images/base.png" alt></p>
<script type="math/tex; mode=display">
\begin{array}{l}\left\{ \begin{matrix}
h=&WX+b\\
S=&f(h)
\end{matrix}\right.
\end{array}</script><p>假设已知损失对$S$的梯度$\frac{\partial J}{\partial S}$:</p>
<script type="math/tex; mode=display">
\begin{array}{l}\left\{ \begin{matrix}
\frac{\partial J}{\partial h}=\frac{\partial J}{\partial S}\frac{d S}{d h}\\
\\
\frac{\partial J}{\partial X}=\frac{\partial J}{\partial h}W^T\\ \\
\frac{\partial J}{\partial W}=X^T\frac{\partial J}{\partial h}\\ \\
\frac{\partial J}{\partial b}=SumCol(\frac{\partial J}{\partial h})

\end{matrix}\right.
\end{array}</script><p>具体推导过程请参考：<a href="https://zhuanlan.zhihu.com/p/79657669" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79657669</a></p>
<p>下面介绍RNN的反向传播，如图所示：<br><img src="./images/RNN_bp1.png" alt><br><img src="./images/RNN_bp2.png" alt><br><img src="./images/RNN_bp3.jpg" alt><br>因为共享权重，所以整个RNN网络对$V、W、U$的梯度为:</p>
<script type="math/tex; mode=display">
\frac{\partial J}{\partial V}=\sum_{i=1}^{t} s_{i}^{T} \frac{\partial J}{\partial o_{i}}; \quad \frac{\partial J}{\partial W}=\sum_{i=1}^{t-1} s_{i}^{T} \frac{\partial J}{\partial h_{i+1}}; \quad \frac{\partial J}{\partial U}=\sum_{i=1}^{t} x_{i}^{T} \frac{\partial J}{\partial h_{i}}</script><h2 id="3-RNN并行加速计算"><a href="#3-RNN并行加速计算" class="headerlink" title="3. RNN并行加速计算"></a>3. RNN并行加速计算</h2><h3 id="3-1-前向并行运算"><a href="#3-1-前向并行运算" class="headerlink" title="3.1 前向并行运算"></a>3.1 <strong>前向并行运算</strong></h3><p>因为RNN为延时网络，网络的每个输入都与前一个时刻的输出有关系，因此，当输入只有一句话时，无法并行计算。当有输入为一个batch时，如何并行计算呢？<br><img src="./images/RNN-并行1.png" alt></p>
<p><img src="./images/RNN-并行2.jpg" alt></p>
<p>也就是说，可以将一个batch的样本在某一个时刻的输入输出并行，加速计算，而不是将一个样本的整个过程并行（因为依赖性无法并行）。</p>
<h3 id="3-2-反向并行计算"><a href="#3-2-反向并行计算" class="headerlink" title="3.2 反向并行计算"></a>3.2 <strong>反向并行计算</strong></h3><p>反向并行运算方式如下图所示：<br><img src="./images/RNN-并行3.jpg" alt></p>
<h2 id="4-双向RNN"><a href="#4-双向RNN" class="headerlink" title="4. 双向RNN"></a>4. 双向RNN</h2><p><img src="./images/RNN-双向.jpg" alt><br>注：图中的$W与\hat{W}$、$U与\hat{U}$、$V与\hat{V}$不同。</p>
<h2 id="5-DeepRNN"><a href="#5-DeepRNN" class="headerlink" title="5. DeepRNN"></a>5. DeepRNN</h2><p><img src="./images/RNN-DeepRnn.png" alt></p>
<p>参考资料：深度之眼</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chennan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chennan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
