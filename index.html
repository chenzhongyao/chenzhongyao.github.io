<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chenzhongyao.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="chenzhongyao&#39;s website">
<meta property="og:url" content="https://chenzhongyao.github.io/index.html">
<meta property="og:site_name" content="chenzhongyao&#39;s website">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="chennan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://chenzhongyao.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>chenzhongyao's website</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">chenzhongyao's website</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/22/%E9%82%AF%E9%83%B8%E8%B4%AD%E6%88%BF%E7%BC%B4%E7%A8%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/22/%E9%82%AF%E9%83%B8%E8%B4%AD%E6%88%BF%E7%BC%B4%E7%A8%8E/" class="post-title-link" itemprop="url">邯郸购房缴税</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-22 09:08:12 / 修改时间：09:08:48" itemprop="dateCreated datePublished" datetime="2020-06-22T09:08:12+08:00">2020-06-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="邯郸"><a href="#邯郸" class="headerlink" title="邯郸:"></a>邯郸:</h2><h4 id="契税"><a href="#契税" class="headerlink" title="契税"></a>契税</h4><p><strong>契税一般是3%，如果是首次购房，可以开具首次购房证明，如果购买的房子面积小于90平米，可以按1%缴纳，如果面积大于90平米小于140平米，可以按照1.5%缴纳，如果大于140平按3%。如果是2套房,一律按3%缴纳.</strong></p>
<h4 id="印花税"><a href="#印花税" class="headerlink" title="印花税"></a>印花税</h4><p><strong>印花税（0.1%,买卖双方各0.05％），印花税是针对合同或者具有合同性质的凭证，产权转移书据，营业账簿，权利、许可证照和经财政部确定征税的其他凭证所收的一类税费。对于购房者而言，印花税的税率是0.05％，即购房者应纳税额为计税价格×0.05％的数值，印花税采取由纳税人自行缴纳完税的方式。</strong></p>
<h4 id="手续费-查到两个-差不多"><a href="#手续费-查到两个-差不多" class="headerlink" title="手续费(查到两个,差不多)"></a>手续费(查到两个,差不多)</h4><p>1.房屋买卖手续费：120平方米以下1000元，120平方米以上3000元，买卖双方各负担一半。</p>
<p>2.二手房交易手续费总额：住宅6元/平米*实际测绘面积，非住宅10元/平米</p>
<h4 id="营业税"><a href="#营业税" class="headerlink" title="营业税"></a>营业税</h4><p>营业税由城市维护建设税、教育费附加、地方教育附加和销售营业税组成，征收税率为5.6％，个人购买超过２年（含２年）的普通住宅对外销售的，免征营业税。</p>
<h4 id="测绘费"><a href="#测绘费" class="headerlink" title="测绘费"></a>测绘费</h4><p>测绘费：1.36元/平米　　总额=1.36元/平米*实际测绘面积(08年4月后新政策房改房测绘费标准：面积75平米以下收200元，75平米以上144平米以下收300元，144平米以上收400元)一般说来房改房都是需要测绘的，商品房如果原产权证上没有济南市房管局的测绘章也是需要测绘的。</p>
<h4 id="登记费"><a href="#登记费" class="headerlink" title="登记费"></a>登记费</h4><p>登记费：(工本费)80元, 共有权证:20元。　</p>
<p>所需材料：　　⑴地税局需要卖方夫妻双方身份证和户口本复印件一套(若卖方夫妻不在同一个户口本上还需提供结婚证复印件一套)、买方身份证复印件一套、网签买卖协议一份、房产证复印件一套(如果卖方配偶已经去世还需要派出所的死亡证明一份)　　⑵房管局需要网签买卖协议一份、房产证原件、新测绘图纸两张，免税证明或完税证明复印件;如省直房改房还需已购公房确认表原件两份和附表一。　　注：房改房过户时需要配偶一起出面签字;若配偶已经去世但使用了其工龄，如果是在房改之后则需要先做继承公证再交易过户;如在房改之前，则应提交派出所开具的死亡证明原件。省直房改房还需填写《已购公房确认表》两份并由单位和省直房改办盖章确认，并提交房改原始票据原件</p>
<h4 id="公证费"><a href="#公证费" class="headerlink" title="公证费"></a>公证费</h4><p>公证处房产收费是按房屋的市场价格来收费的，具体收费标准如下：<br>一：证明土地使用权出让、转让，房屋转让、买卖及股权转让 标的额500000元以下部分，收取比例为0．3％，按比例收费不到200元的，按200元收取，500001元至5000000元部分，收取0．25％，5000001元至10000000元部分， 收取0.2％，10000001元至20000000元部分，收取0.15％，20000001元至50000000元部分，收取0. 1％，50000001元至100000000元部分，收取0．05％，100000001元以上部分，收取0. 01％。</p>
<p>假如120万购买的房屋,需缴纳500000<em>0.3% + 700000</em>0.25%=3250元</p>
<h4 id="个人所得税-卖方缴纳"><a href="#个人所得税-卖方缴纳" class="headerlink" title="个人所得税(卖方缴纳)"></a>个人所得税(卖方缴纳)</h4><p>个人所得税在房产交易过程中需要由卖方缴纳，缴纳比例固定，但是也存在个人所得税减免情况。</p>
<p>个人所得税：(税率交易总额1%或两次交易差的20%卖方缴纳)征收条件以家庭为单位出售非唯一住房需缴纳个人房转让所得税。在这里有两个条件①家庭唯一住宅②购买时间超过5年。如果两个条件同时满足可以免交个人所得税;任何一个条件不满足都必须缴纳个人所得税。</p>
<ul>
<li>计算方式1:</li>
</ul>
<p>纳税人(卖方)能在地税系统中查到房屋原值，或能提供房屋原值等费用，个人所得税计算方法为：</p>
<p>个人所得税=(计税价格-房屋原值-原契税-本次交易所缴纳税等合理费用)×20%。</p>
<p>　　举例：如果卖方出卖不满是“满五唯一：的房子，计税价格为100万，原值、原契税以及相关税费合计70万元。那么，卖方需要缴纳的个人所得税为：(100-70)×20%=6万元。</p>
<ul>
<li>计算方式2:</li>
</ul>
<p>纳税人(卖方)不能在地税系统中查到房屋原值，也不能提供房屋原值等费用，个人所得税计算方法为：个人所得税=计税价格×1%。</p>
<p>　　举例：卖家不满五或不唯一的住房出售价为100万售。买家承担税费，全额的1%。那么，卖方需要缴纳的个人所得税为：100×1%=1万元。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/20/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/20/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-20 20:11:59" itemprop="dateCreated datePublished" datetime="2020-06-20T20:11:59+08:00">2020-06-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/20/%E5%86%9B%E9%98%9F%E6%96%87%E8%81%8C%E5%8E%86%E5%B9%B4%E8%80%83%E8%AF%95%E7%9C%9F%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/20/%E5%86%9B%E9%98%9F%E6%96%87%E8%81%8C%E5%8E%86%E5%B9%B4%E8%80%83%E8%AF%95%E7%9C%9F%E9%A2%98/" class="post-title-link" itemprop="url">军队文职历年考试真题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-20 13:42:28 / 修改时间：20:12:21" itemprop="dateCreated datePublished" datetime="2020-06-20T13:42:28+08:00">2020-06-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="2013年军队文职真题及答案"><a href="#2013年军队文职真题及答案" class="headerlink" title="2013年军队文职真题及答案"></a>2013年军队文职真题及答案</h2><div class="pdfobject-container" data-target="2013年军队文职真题及答案解析.pdf" data-height="600px"></div>
<h2 id="2014年军队文职真题及答案"><a href="#2014年军队文职真题及答案" class="headerlink" title="2014年军队文职真题及答案"></a>2014年军队文职真题及答案</h2><div class="pdfobject-container" data-target="2014年军队文职真题及答案解析.pdf" data-height="600px"></div>
<h2 id="2015年军队文职真题及答案"><a href="#2015年军队文职真题及答案" class="headerlink" title="2015年军队文职真题及答案"></a>2015年军队文职真题及答案</h2><div class="pdfobject-container" data-target="2015年军队文职真题及答案解析.pdf" data-height="600px"></div>
<h2 id="2016年军队文职真题及答案"><a href="#2016年军队文职真题及答案" class="headerlink" title="2016年军队文职真题及答案"></a>2016年军队文职真题及答案</h2><div class="pdfobject-container" data-target="2016年军队文职真题及答案解析.pdf" data-height="600px"></div>
<h2 id="2018年军队文职真题及答案"><a href="#2018年军队文职真题及答案" class="headerlink" title="2018年军队文职真题及答案"></a>2018年军队文职真题及答案</h2><div class="pdfobject-container" data-target="2018年军队文职真题及答案解析.pdf" data-height="600px"></div>
<h2 id="2019年军队文职真题及答案"><a href="#2019年军队文职真题及答案" class="headerlink" title="2019年军队文职真题及答案"></a>2019年军队文职真题及答案</h2><div class="pdfobject-container" data-target="2019年军队文职真题及答案解析.pdf" data-height="600px"></div>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/18/RNN%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E3%80%81%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/RNN%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD%E3%80%81%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E4%B8%8E%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">RNN前向传播、反向传播与并行计算（非常详细）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 23:02:56" itemprop="dateCreated datePublished" datetime="2020-06-18T23:02:56+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-20 20:12:09" itemprop="dateModified" datetime="2020-06-20T20:12:09+08:00">2020-06-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RNN前向传播、反向传播与并行计算-非常详细"><a href="#RNN前向传播、反向传播与并行计算-非常详细" class="headerlink" title="RNN前向传播、反向传播与并行计算(非常详细)"></a>RNN前向传播、反向传播与并行计算(非常详细)</h1><h2 id="1-RNN前向传播"><a href="#1-RNN前向传播" class="headerlink" title="1. RNN前向传播"></a>1. RNN前向传播</h2><p>在介绍RNN之前，首先比较一下RNN与CNN的区别：</p>
<ul>
<li>RNN是一类用于处理序列数据的神经网络，CNN是一类用于处理网格化数据(如一幅图像)的神经网络。</li>
<li>RNN可以扩展到更长的序列，大多数RNN也能处理可变长度的序列。CNN可以很容易地扩展到具有很大宽度和高度的图像，并且可以处理可变大小的图像。</li>
</ul>
<p><img src="./images/RNN-前向.jpg" alt="RNN示意图"><br>RNN的前向传播如图所示，其中$f(x)$代表激活函数，输出的label可以使用one-hot形式。图中所有的$U、W、V、b_1、b_2$全部相同，类似于CNN中的权值共享。CNN通过权值共享可以处理任意大小的图片，RNN通过权值共享，可以处理任意序列长度的语音、句子。</p>
<p>损失函数：</p>
<script type="math/tex; mode=display">
J=\sum_{i=1}^{t}||o_i-\hat{o}_i||^2=J_1+J_2+...+J_t（J_i为MSE损失或CE损失）</script><h2 id="2-RNN反向传播"><a href="#2-RNN反向传播" class="headerlink" title="2.RNN反向传播"></a>2.RNN反向传播</h2><p>在介绍RNN反向传播之前，先回顾一下基本神经元的反向传播算法：<br><img src="./images/base.png" alt></p>
<script type="math/tex; mode=display">
\begin{array}{l}\left\{ \begin{matrix}
h=&WX+b\\
S=&f(h)
\end{matrix}\right.
\end{array}</script><p>假设已知损失对$S$的梯度$\frac{\partial J}{\partial S}$:</p>
<script type="math/tex; mode=display">
\begin{array}{l}\left\{ \begin{matrix}
\frac{\partial J}{\partial h}=\frac{\partial J}{\partial S}\frac{d S}{d h}\\
\\
\frac{\partial J}{\partial X}=\frac{\partial J}{\partial h}W^T\\ \\
\frac{\partial J}{\partial W}=X^T\frac{\partial J}{\partial h}\\ \\
\frac{\partial J}{\partial b}=SumCol(\frac{\partial J}{\partial h})

\end{matrix}\right.
\end{array}</script><p>具体推导过程请参考：<a href="https://zhuanlan.zhihu.com/p/79657669" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79657669</a></p>
<p>下面介绍RNN的反向传播，如图所示：<br><img src="./images/RNN_bp1.png" alt><br><img src="./images/RNN_bp2.png" alt><br><img src="./images/RNN_bp3.jpg" alt><br>因为共享权重，所以整个RNN网络对$V、W、U$的梯度为:</p>
<script type="math/tex; mode=display">
\frac{\partial J}{\partial V}=\sum_{i=1}^{t} s_{i}^{T} \frac{\partial J}{\partial o_{i}}; \quad \frac{\partial J}{\partial W}=\sum_{i=1}^{t-1} s_{i}^{T} \frac{\partial J}{\partial h_{i+1}}; \quad \frac{\partial J}{\partial U}=\sum_{i=1}^{t} x_{i}^{T} \frac{\partial J}{\partial h_{i}}</script><h2 id="3-RNN并行加速计算"><a href="#3-RNN并行加速计算" class="headerlink" title="3. RNN并行加速计算"></a>3. RNN并行加速计算</h2><h3 id="3-1-前向并行运算"><a href="#3-1-前向并行运算" class="headerlink" title="3.1 前向并行运算"></a>3.1 <strong>前向并行运算</strong></h3><p>因为RNN为延时网络，网络的每个输入都与前一个时刻的输出有关系，因此，当输入只有一句话时，无法并行计算。当有输入为一个batch时，如何并行计算呢？<br><img src="./images/RNN-并行1.png" alt></p>
<p><img src="./images/RNN-并行2.jpg" alt></p>
<p>也就是说，可以将一个batch的样本在某一个时刻的输入输出并行，加速计算，而不是将一个样本的整个过程并行（因为依赖性无法并行）。</p>
<h3 id="3-2-反向并行计算"><a href="#3-2-反向并行计算" class="headerlink" title="3.2 反向并行计算"></a>3.2 <strong>反向并行计算</strong></h3><p>反向并行运算方式如下图所示：<br><img src="./images/RNN-并行3.jpg" alt></p>
<h2 id="4-双向RNN"><a href="#4-双向RNN" class="headerlink" title="4. 双向RNN"></a>4. 双向RNN</h2><p><img src="./images/RNN-双向.jpg" alt><br>注：图中的$W与\hat{W}$、$U与\hat{U}$、$V与\hat{V}$不同。</p>
<h2 id="5-DeepRNN"><a href="#5-DeepRNN" class="headerlink" title="5. DeepRNN"></a>5. DeepRNN</h2><p><img src="./images/RNN-DeepRnn.png" alt></p>
<p>参考资料：深度之眼</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/18/CNN%E7%9A%84%E5%89%8D%E5%90%91%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/CNN%E7%9A%84%E5%89%8D%E5%90%91%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/" class="post-title-link" itemprop="url">四张图彻底搞懂CNN反向传播算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 23:02:52" itemprop="dateCreated datePublished" datetime="2020-06-18T23:02:52+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-20 20:11:59" itemprop="dateModified" datetime="2020-06-20T20:11:59+08:00">2020-06-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="四张图彻底搞懂CNN反向传播算法"><a href="#四张图彻底搞懂CNN反向传播算法" class="headerlink" title="四张图彻底搞懂CNN反向传播算法"></a>四张图彻底搞懂CNN反向传播算法</h1><p>阅读本文之前，请首先阅读之前讲述的全连接层的反向传播算法详细推导过程： <a href="https://zhuanlan.zhihu.com/p/79657669" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79657669</a><br>已经了解反向传播算法请自动忽略。</p>
<h2 id="1-卷积层的反向传播"><a href="#1-卷积层的反向传播" class="headerlink" title="1. 卷积层的反向传播"></a>1. 卷积层的反向传播</h2><p>直接上图：<br><img src="./images/cnn.png" alt><br>假设输入为一张单通道图像$x$，卷积核大小为$2\times 2$，输出为$y$。为了加速计算，首先将$x$按卷积核滑动顺序依次展开，如上图所示。其中，$\hat{x}$中的红色框代表$x$中的红色框展开后的结果，将$x$依次按照此方式展开，可得$\hat{x}$。同理可得$\hat{w}$，然后通过矩阵相乘可得输出$\hat{y}$（$\hat{y}$与$y$等价）。此时，已经将CNN转化为FC，反向传播算法与<a href="https://zhuanlan.zhihu.com/p/79657669" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79657669</a> 完全一致，这里不再做详细介绍。当输入图像有N个样本时，应该怎么算呢？</p>
<p>当有$N$个样本，即batch=N时，前向与反向传播方式如下图所示：<br><img src="./images/cnn-batch.png" alt><br>其中，输入图像batch=3,使用2个$2\times 2\times 3$的卷积核，输出两张图像，如图所示。红色框、黄色框代表的是卷积核以及使用该卷积核得到的输出图像$y$。当输入图像为一个batch时，$x、w$的转化方式如上图，首先将输入图像与卷积核分别按单通道图像展开，然后将展开后的矩阵在行方向级联。此时，已经将CNN转化为了FC，反向传播算法与<a href="https://zhuanlan.zhihu.com/p/79657669" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79657669</a> 完全一致，这里不再做过多介绍。</p>
<h2 id="2-Average-pooling的反向传播"><a href="#2-Average-pooling的反向传播" class="headerlink" title="2. Average pooling的反向传播"></a>2. Average pooling的反向传播</h2><p><img src="./images/average-pooling.png" alt><br>$\frac{\partial J}{\partial w}$不用求，因为$w$为常数。$\frac{\partial J}{\partial x<em>{ij}}=\Sigma \frac{\partial J}{\partial \hat{x}</em>{ij}}$</p>
<h2 id="3-Max-pooling的反向传播"><a href="#3-Max-pooling的反向传播" class="headerlink" title="3. Max-pooling的反向传播"></a>3. Max-pooling的反向传播</h2><p><img src="./images/max-pooling.png" alt><br>遍历$\hat{x}$的每一行，找出此行最大值的索引$(i,j)$，然后将$\frac{\partial J}{\partial \hat{x}}$中索引为$(i,j)$的值设为$\frac{\partial J}{\partial \hat{y}}$对应行的值，将此行其余列的值设为0，如上图所示红框所示。假设$\hat{x}$中(1,1)处的值是第一行中最大的值，则将$\frac{\partial J}{\partial y<em>{11}}$赋值给$\frac{\partial J}{\partial \hat{x}}$中索引为$(1,1)$的位置。最后计算:$\frac{\partial J}{\partial x</em>{ij}}=\Sigma \frac{\partial J}{\partial \hat{x}_{ij}}$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/18/LSTM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/LSTM/" class="post-title-link" itemprop="url">LSTM前向传播与反向传播算法推导（非常详细）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 23:02:52" itemprop="dateCreated datePublished" datetime="2020-06-18T23:02:52+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-20 20:12:09" itemprop="dateModified" datetime="2020-06-20T20:12:09+08:00">2020-06-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="LSTM前向传播与反向传播算法推导（非常详细）"><a href="#LSTM前向传播与反向传播算法推导（非常详细）" class="headerlink" title="LSTM前向传播与反向传播算法推导（非常详细）"></a>LSTM前向传播与反向传播算法推导（非常详细）</h2><h3 id="1-长短期记忆网络LSTM"><a href="#1-长短期记忆网络LSTM" class="headerlink" title="1.长短期记忆网络LSTM"></a>1.长短期记忆网络LSTM</h3><p>LSTM(Long short-term memory)通过刻意的设计来避免长期依赖问题，是一种特殊的RNN。长时间记住信息实际上是 LSTM 的默认行为，而不是需要努力学习的东西！</p>
<p>所有递归神经网络都具有神经网络的链式重复模块。在标准的RNN中，这个重复模块具有非常简单的结构，例如只有单个tanh层，如下图所示。<br><img src="./images/lstm-rnn.jpg" alt><br>LSTM具有同样的结构，但是重复的模块拥有不同的结构，如下图所示。与RNN的单一神经网络层不同，这里有四个网络层，并且以一种非常特殊的方式进行交互。<br><img src="./images/lstm.jpg" alt></p>
<h4 id="1-1-LSTM—遗忘门"><a href="#1-1-LSTM—遗忘门" class="headerlink" title="1.1 LSTM—遗忘门"></a>1.1 LSTM—遗忘门</h4><p><img src="./images/lstm-1.jpg" alt><br>LSTM 的第一步要决定从细胞状态中舍弃哪些信息。这一决定由所谓“遗忘门层”的 S 形网络层做出。它接收 $h<em>{t-1}$ 和 $x_t$，并且对细胞状态 $C</em>{t−1}$ 中的每一个数来说输出值都介于 0 和 1 之间。1 表示“完全接受这个”，0 表示“完全忽略这个”。</p>
<h4 id="1-2-LSTM—输入门"><a href="#1-2-LSTM—输入门" class="headerlink" title="1.2 LSTM—输入门"></a>1.2 LSTM—输入门</h4><p><img src="./images/lstm-2.jpg" alt><br>下一步就是要确定需要在细胞状态中保存哪些新信息。这里分成两部分。第一部分，一个所谓“输入门层”的 S 形网络层确定哪些信息需要更新。第二部分，一个 tanh 形网络层创建一个新的备选值向量—— $\tilde{C}_t$，可以用来添加到细胞状态。在下一步中我们将上面的两部分结合起来，产生对状态的更新。</p>
<h4 id="1-3-LSTM—细胞状态更新"><a href="#1-3-LSTM—细胞状态更新" class="headerlink" title="1.3 LSTM—细胞状态更新"></a>1.3 LSTM—细胞状态更新</h4><p><img src="./images/lstm-3.jpg" alt><br>现在更新旧的细胞状态 $C_{t−1}$ 更新到 $C_t$。先前的步骤已经决定要做什么，我们只需要照做就好。<br>我们对旧的状态乘以 $f_t$，用来忘记我们决定忘记的事。然后我们加上 $i_t\odot\tilde{C}_t$，这是新的候选值，根据我们对每个状态决定的更新值按比例进行缩放。</p>
<h4 id="1-4-LSTM—输出门"><a href="#1-4-LSTM—输出门" class="headerlink" title="1.4 LSTM—输出门"></a>1.4 LSTM—输出门</h4><p><img src="./images/lstm-4.jpg" alt><br>最后，我们需要确定输出值。输出依赖于我们的细胞状态，但会是一个“过滤的”版本。首先我们运行 S 形网络层，用来确定细胞状态中的哪些部分可以输出。然后，我们把细胞状态输入 tanh（把数值调整到 −1 和 1 之间）再和 S 形网络层的输出值相乘，部这样我们就可以输出想要输出的分。</p>
<h3 id="2-LSTM的变种以及前向、反向传播"><a href="#2-LSTM的变种以及前向、反向传播" class="headerlink" title="2. LSTM的变种以及前向、反向传播"></a>2. LSTM的变种以及前向、反向传播</h3><p>目前所描述的还只是一个相当一般化的 LSTM 网络。但并非所有 LSTM 网络都和之前描述的一样。事实上，几乎所有文章都会改进 LSTM 网络得到一个特定版本。差别是次要的，但有必要认识一下这些变种。</p>
<h4 id="2-1-带有”窥视孔连接”的LSTM"><a href="#2-1-带有”窥视孔连接”的LSTM" class="headerlink" title="2.1 带有”窥视孔连接”的LSTM"></a>2.1 带有”窥视孔连接”的LSTM</h4><p>一个流行的 LSTM 变种由 Gers 和 Schmidhuber 提出，在 LSTM 的基础上添加了一个“窥视孔连接”，这意味着我们可以让门网络层输入细胞状态。<br><img src="./images/lstm-5.jpg" alt><br>上图中我们为所有门添加窥视孔，但许多论文只为部分门添加。</p>
<p><strong>前向传播：</strong><br>在t时刻的前向传播公式为：</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{l}
    {i_t=\sigma(\tilde{i}_t)=\sigma(W_{xi}x_t+W_{hi}h_{t-1}+W_{ci}c_{t-1}+b_i)} \\
    {f_t=\sigma(\tilde{f}_t)=\sigma(W_{xf}x_t+W_{hf}h_{t-1}+W_{cf}c_{t-1}+b_f) }\\
    {g_t=\tanh(\tilde{g}_t)=\tanh(W_{xg}x_t+W_{hg}h_{t-1}+b_g)} \\
    {o_t=\sigma(\tilde{o}_t)=\sigma(W_{xo}x_t+W_{ho}h_{t-1}+W_{co}c_{t}+b_o) }\\
    {c_t=c_{t-1}\odot f_t+g_t\odot i_t}\\
    {m_t=\tanh(c_t)}\\
    {h_t=o_t\odot m_t}\\
    {y_t=W_{yh}h_t+b_y}

\end{array}\right.</script><p><strong>反向传播：</strong><br>为了更直观的推导反向传播算法，将上图转化为下图：<br><img src="./images/lstm-bp.png" alt><br>对反向传播算法了解不够透彻的，请参考<a href="https://zhuanlan.zhihu.com/p/79657669，这里有详细的推导过程，本文将直接使用https://zhuanlan.zhihu.com/p/79657669的结论。" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79657669，这里有详细的推导过程，本文将直接使用https://zhuanlan.zhihu.com/p/79657669的结论。</a></p>
<p>已知：$\frac{\partial J}{\partial y<em>t},\frac{\partial J}{\partial c</em>{t+1}},\frac{\partial J}{\partial \tilde{o}<em>{t+1}},\frac{\partial J}{\partial \tilde{f}</em>{t+1}},\frac{\partial J}{\partial \tilde{i}<em>{t+1}},\frac{\partial J}{\partial \tilde{g}</em>{t+1}}$,求某个节点梯度时，首先应该找到该节点的输出节点，然后分别计算所有输出节点的梯度乘以输出节点对该节点的梯度，最后相加即可得到该节点的梯度。如计算$\frac{\partial J}{\partial h<em>t}$时，找到$h_t$节点的所有输出节点$y_t、 \tilde{o}</em>{t+1}、\tilde{f}<em>{t+1}、\tilde{i}</em>{t+1}、\tilde{g}<em>{t+1}$，然后分别计算输出节点的梯度(如$\frac{\partial J}{\partial y_t}$)与输出节点对$h_t$的梯度的乘积（如$\frac{\partial J}{\partial y_t}W</em>{yh}^T$），最后相加即可得到节点$h_t$的梯度:</p>
<script type="math/tex; mode=display">
\frac{\partial J}{\partial h_t}=\frac{\partial J}{\partial y_t}W_{yh}^T+\frac{\partial J}{\partial \tilde{o}_{t+1}}W_{ho}^T+\frac{\partial J}{\partial \tilde{f}_{t+1}}W_{hf}^T+\frac{\partial J}{\partial \tilde{i}_{t+1}}W_{hi}^T+\frac{\partial J}{\partial \tilde{g}_{t+1}}W_{hg}^T</script><p>同理可得t时刻其它节点的梯度：</p>
<script type="math/tex; mode=display">
\left \{\begin{array}{l}
    \frac{\partial J}{\partial h_t}=\frac{\partial J}{\partial y_t}W_{yh}^T+\frac{\partial J}{\partial \tilde{o}_{t+1}}W_{ho}^T+\frac{\partial J}{\partial \tilde{f}_{t+1}}W_{hf}^T+\frac{\partial J}{\partial \tilde{i}_{t+1}}W_{hi}^T+\frac{\partial J}{\partial \tilde{g}_{t+1}}W_{hg}^T \\ \\
    \frac{\partial J}{\partial m_t} = \frac{\partial J}{\partial h_t} \odot o_t \\ \\
    \frac{\partial J}{\partial c_t} = \frac{\partial J}{\partial m_t}\frac{dm_t}{dc_t}+ \frac{\partial J}{\partial c_{t+1}}\odot f_{t+1} +\frac{\partial J}{\partial \tilde{f}_{t+1}}W_{cf}^T+\frac{\partial J}{\partial \tilde{i}_{t+1}}W_{ci}^T \\ \\
    \left. \begin{array}{l}
         \frac{\partial J}{\partial g_t} = \frac{\partial J}{\partial c_t}\odot i_t \\
         \frac{\partial J}{\partial i_t} = \frac{\partial J}{\partial c_t} \odot g_t \\
         \frac{\partial J}{\partial f_t} = \frac{\partial J}{\partial c_t} \odot c_{t-1} \\
         \frac{\partial J}{\partial o_t} = \frac{\partial J}{\partial h_t} \odot m_t
    \end{array} \right \} \Rightarrow \left\{ \begin{array}{l}
        \frac{\partial J}{\partial \tilde{g}_t} = \frac{\partial J}{\partial g_t}(1-g_t^2) \\
        \frac{\partial J}{\partial \tilde{i}_t} = \frac{\partial J}{\partial i_t}i_t(1-i_t) \\
        \frac{\partial J}{\partial \tilde{f}_t} = \frac{\partial J}{\partial f_t}f_t(1-f_t) \\
        \frac{\partial J}{\partial \tilde{o}_t} = \frac{\partial J}{\partial o_t}i_t(1-o_t) \\
    \end{array}\right. \\ \\
    \frac{\partial J}{\partial x_t} = \frac{\partial J}{\partial \tilde{o}_t}W_{xo}^T+\frac{\partial J}{\partial \tilde{f}_t}W_{xf}^T+ \frac{\partial J}{\partial \tilde{i}_t}W_{xi}^T+\frac{\partial J}{\partial \tilde{g}_t}W_{xg}^T\\
\end{array}\right.</script><p>对参数的梯度：</p>
<script type="math/tex; mode=display">
\left \{\begin{array}{l}
    \frac{\partial J}{\partial W_{ho}} = h_t^T\frac{\partial J}{\partial \tilde{o}_{t+1}} \\
    \frac{\partial J}{\partial W_{hf}} = h_t^T\frac{\partial J}{\partial \tilde{f}_{t+1}} \\
    \frac{\partial J}{\partial W_{hi}} = h_t^T\frac{\partial J}{\partial \tilde{i}_{t+1}} \\
    \frac{\partial J}{\partial W_{hg}} = h_t^T\frac{\partial J}{\partial \tilde{g}_{t+1}}
\end{array} \right. 

\left \{\begin{array}{l}
    \frac{\partial J}{\partial W_{yh}} = h_t^T\frac{\partial J}{\partial y_t} \\
    \frac{\partial J}{\partial W_{cf}} = c_t^T\frac{\partial J}{\partial \tilde{f}_{t+1}} \\
    \frac{\partial J}{\partial W_{ci}} = c_t^T\frac{\partial J}{\partial \tilde{i}_{t+1}} \\
    \frac{\partial J}{\partial W_{co}} = c_t^T\frac{\partial J}{\partial \tilde{o}_{t}} 
\end{array} \right. 

\left \{\begin{array}{l}
    \frac{\partial J}{\partial W_{xo}} = x_t^T\frac{\partial J}{\partial \tilde{o}_{t}} \\
    \frac{\partial J}{\partial W_{xf}} = x_t^T\frac{\partial J}{\partial \tilde{f}_{t}} \\
    \frac{\partial J}{\partial W_{xi}} = x_t^T\frac{\partial J}{\partial \tilde{i}_{t}} \\
    \frac{\partial J}{\partial W_{xg}} = x_t^T\frac{\partial J}{\partial \tilde{g}_{t}} \\
\end{array} \right.</script><h4 id="2-2-GRU"><a href="#2-2-GRU" class="headerlink" title="2.2 GRU"></a>2.2 GRU</h4><p>一个更有意思的 LSTM 变种称为 Gated Recurrent Unit（GRU），由 Cho 等人提出。LSTM通过三个门函数输入门、遗忘门和输出门分别控制输入值、记忆值和输出值。而GRU中只有两个门：更新门$z_t$和重置门$r_t$，如下图所示。更新门用于控制前一时刻的状态信息被带入到当前状态中的程度，更新门的值越大说明前一时刻的状态信息带入越多；重置门控制前一时刻状态有多少信息被写入到当前的候选集$\tilde{h}_t$上，重置门越小，前一状态的信息被写入的越少。这样做使得 GRU 比标准的 LSTM 模型更简单，因此正在变得流行起来。<br><img src="./images/lstm-7.jpg" alt><br>为了更加直观的推导反向传播公式，将上图转化为如下形式：<br><img src="./images/lstm-gru.png" alt><br><strong>GRU的前向传播：</strong> 在t时刻的前向传播公式为：</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{l}
    {r_t=\sigma(\tilde{r}_t)=\sigma(W_{xr}x_t+W_{hr}h_{t-1}+b_r)} \\
    {z_t=\sigma(\tilde{z}_t)=\sigma(W_{xz}x_t+W_{hz}h_{t-1}+b_z) }\\
    {s_t=\tanh(\tilde{s}_t)}=\tanh[W_{xs}x_t+(h_{t-1}\odot r_t)W_{hs}+b_s]  \\
    {h_t=z_t\odot s_t + h_{t-1}\odot (1-z_t)}\\
    {y_t=W_{yh}h_t+b_y}
\end{array}\right.</script><p><strong>GRU的反向传播：</strong><br>t时刻其它节点的梯度:</p>
<script type="math/tex; mode=display">
\left\{ \begin{array}{l}
    \frac{\partial J}{\partial h_t}=\frac{\partial J}{\partial y_t}W_{hy}^T+\frac{\partial J}{\partial \tilde{r}_{t+1}}W_{hr}^T+ \frac{\partial J}{\partial \tilde{z}_{t+1}}W_{hz}^T+ \frac{\partial J}{\partial \tilde{s}_{t+1}}W_{hs}^T \odot  r_t + \frac{\partial J}{\partial \tilde{h}_{t+1}}\odot(1-z_t)\\
\left.\begin{array}{l}
    \frac{\partial J}{\partial s_t}=\frac{\partial J}{\partial h_t}\odot z_t\\
    \frac{\partial J}{\partial z_t}=\frac{\partial J}{\partial h_t}\odot s_t + \frac{\partial J}{\partial h_t}\odot (-h_{t-1})  \\
    \frac{\partial J}{\partial r_t}=\frac{\partial J}{\partial \tilde{s}_t}W_{hs}^T\odot h_{t-1} \\
\end{array}\right\} \Rightarrow
\left\{ \begin{array}{l}
    \frac{\partial J}{\partial \tilde{s}_t}=\frac{\partial J}{\partial s_t}(1-s_t^2)\\
    \frac{\partial J}{\partial \tilde{z}_t}=\frac{\partial J}{\partial z_t}z_t(1-z_t)  \\
    \frac{\partial J}{\partial \tilde{r}_t}=\frac{\partial J}{\partial r_t}r_t(1-r_t) \\
\end{array}\right. 
\\
    \frac{\partial J}{\partial x_t} = \frac{\partial J}{\partial \tilde{r}_t}W_{xr}^T+\frac{\partial J}{\partial \tilde{z}_t}W_{xz}^T+ \frac{\partial J}{\partial \tilde{s}_t}W_{xs}^T\\
\end{array}\right.</script><p>对参数的梯度：</p>
<script type="math/tex; mode=display">
\left \{\begin{array}{l}
    \frac{\partial J}{\partial W_{hy}} = h_t^T\frac{\partial J}{\partial y_t} \\
    \frac{\partial J}{\partial W_{hs}} = (h_{t-1}\odot r_t)^T\frac{\partial J}{\partial \tilde{s}_{t}} \\
    \frac{\partial J}{\partial W_{hz}} = h_{t-1}^T\frac{\partial J}{\partial \tilde{z}_{t}} \\
    \frac{\partial J}{\partial W_{hr}} = h_{t-1}^T\frac{\partial J}{\partial \tilde{r}_{t}}
\end{array} \right. 
\left \{\begin{array}{l}
    \frac{\partial J}{\partial W_{xs}} = x_t^T\frac{\partial J}{\partial \tilde{s}_{t}} \\
    \frac{\partial J}{\partial W_{xz}} = x_t^T\frac{\partial J}{\partial \tilde{f}_{z}} \\
    \frac{\partial J}{\partial W_{xr}} = x_t^T\frac{\partial J}{\partial \tilde{r}_{t}} 
\end{array} \right.</script><h4 id="2-3-结合遗忘门与输入门的LSTM"><a href="#2-3-结合遗忘门与输入门的LSTM" class="headerlink" title="2.3 结合遗忘门与输入门的LSTM"></a>2.3 结合遗忘门与输入门的LSTM</h4><p>另一个变种把遗忘和输入门结合起来。同时确定要遗忘的信息和要添加的新信息，而不再是分开确定。当输入的时候才会遗忘，当遗忘旧信息的时候才会输入新数据。<br><img src="./images/lstm-6.jpg" alt><br>前向与反向算法与上述变种相同，这里不再做过多推导。</p>
<blockquote>
<p>参考资料：<a href="https://www.cnblogs.com/xuruilong100/p/8506949.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuruilong100/p/8506949.html</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/18/svd%E5%88%86%E8%A7%A3%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/svd%E5%88%86%E8%A7%A3%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">SVD奇异值分解逐步推导</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 23:02:52" itemprop="dateCreated datePublished" datetime="2020-06-18T23:02:52+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-20 20:12:09" itemprop="dateModified" datetime="2020-06-20T20:12:09+08:00">2020-06-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="SVD奇异值分解逐步推导"><a href="#SVD奇异值分解逐步推导" class="headerlink" title="SVD奇异值分解逐步推导"></a>SVD奇异值分解逐步推导</h2><h3 id="1-回顾特征值和特征向量"><a href="#1-回顾特征值和特征向量" class="headerlink" title="1. 回顾特征值和特征向量"></a>1. 回顾特征值和特征向量</h3><p>首先回顾下特征值和特征向量的定义：</p>
<script type="math/tex; mode=display">
Ax=\lambda x</script><p>其中，A是一个$n\times n$的矩阵，$x$是一个$n$维向量，则$\lambda$是矩阵A的一个特征值，而$x$是矩阵A的特征值$\lambda$对应的特征向量。</p>
<p>求出特征值和特征向量有什么好处呢？就是我们可以将矩阵A特征分解。如果我们求出了矩阵A的n个特征值$\lambda _1\leq \lambda_2\leq … \leq\lambda_n$，以及这$n$个特征值所对应的特征向量$w_1, w_2, …, w_n$,那么矩阵A就可以用以下的特征分解表示：</p>
<script type="math/tex; mode=display">
W^{-1}AW=\Lambda \Leftrightarrow A=W\Lambda W^{-1}</script><p>其中，$W$是这$n$个特征向量所组成的$n\times n$维矩阵，而$\Lambda$是将这$n$个特征值作为主对角线的$n\times n$维矩阵。一般情况下，我们会把$W$的这$n$个特征向量标准化，即满足$||w_i||_2=1$，或者$w_i^Tw_i=1$,此时$W$的$n$个特征向量为标准正交基，满足$W^TW=I$，即$W^T=W^{-1}$,也就是说$W$为酉矩阵。这样我们的特征分解表达式可以写成：</p>
<script type="math/tex; mode=display">
A=W\Lambda W^T</script><blockquote>
<p>题外延伸———矩阵压缩：</p>
<p>设$W=(w_1, w_2, w_3,…,w_n)$，则:</p>
<script type="math/tex; mode=display">W^T=\begin{pmatrix}
 w_1^T\\ 
 w_2^T\\ 
 w_3^T\\ 
... \\
w_n^T
\end{pmatrix}</script><p>那么:</p>
<script type="math/tex; mode=display">
A=(w_1, w_2, w_3,...,w_n)\begin{pmatrix}
    \lambda_1&&&\\
    &\lambda_2&&\\
    &&\lambda_3&\\
    &&&...\\
    &&&&\lambda_n
\end{pmatrix}\begin{pmatrix}
 w_1^T\\ 
 w_2^T\\ 
 w_3^T\\ 
... \\
w_n^T
\end{pmatrix}
\\
=\lambda_1w_1w_1^T+\lambda_2w_2w_2^T+\lambda_3w_3w_3^T+...+\lambda_nw_nw_n^T</script><p>假设A为$n\times n$维矩阵，如果正常表示矩阵A共需使用$n^2$个元素，如果将取得的特征值$\lambda_1,\lambda_2,\lambda_3,…,\lambda_n$按从大到小排序，即$\lambda_1\geq\lambda_2\geq\lambda_3\geq…\geq\lambda_n$，则将A的压缩表示为$\lambda_1w_1w_1^T$，即只需要$n+1$个元素。</p>
</blockquote>
<p>注意到要进行特征分解，矩阵A必须为方阵。</p>
<p>那么如果A不是方阵，即行和列不相同时，我们还可以对矩阵进行分解吗？答案是可以，此时我们的SVD登场了。</p>
<h3 id="2-SVD推导"><a href="#2-SVD推导" class="headerlink" title="2. SVD推导"></a>2. SVD推导</h3><h4 id="Step1：矩阵分解"><a href="#Step1：矩阵分解" class="headerlink" title="Step1：矩阵分解"></a>Step1：矩阵分解</h4><p>假如$A$为$m\times n$维矩阵，则$A^TA$为对称正定矩阵。</p>
<blockquote>
<p>证明：1)对称性：$(A^TA)^T=A^TA\Rightarrow 对称性$<br>2)正定性： $x^TA^TAx=(Ax)^T(Ax)\geq 0\Rightarrow正定性$</p>
</blockquote>
<p>对于矩阵A，有$(A^TA)v_i=\lambda _iv_i$，其中$\lambda_i$为特征值，$v_i$为特征向量。假定$(v_i, v_j)$是一组正交基，那么有$v_i^T\cdot v_j=0$，那么：</p>
<script type="math/tex; mode=display">
(Av_i, Av_j)=(Av_i)^T\cdot Av_j=v_i^TA^TAv_j=v_i^T\lambda_jv_j=\lambda_jv_i^Tv_j=0</script><p>因此，$Av_i,Av_j$也是一组正交基，根据上述公式可以推导出$(Av_i, Av_i)=\lambda_iv_i^Tv_i=\lambda_i$,从而可以得到：</p>
<script type="math/tex; mode=display">
|Av_i|^2=\lambda_i</script><script type="math/tex; mode=display">
|Av_i|=\sqrt{\lambda_i}</script><p>根据上述公式，有$\frac{Av_i}{|Av_i|}=\frac{1}{\sqrt{\lambda_i}}Av_i$，令$\frac{1}{\sqrt{\lambda_i}}Av_i=u_i$，可得：</p>
<script type="math/tex; mode=display">
Av_i=\sqrt{\lambda_i}u_i=\delta_i u_i</script><p>其中，$\delta_i=\sqrt{\lambda_i}$，进一步推导：</p>
<script type="math/tex; mode=display">
AV=A(v_1,v_2,...,v_n)=(Av_1,Av_2,...,Av_n)=(\delta_1u_1,\delta_2u_2,...,\delta_nu_n)=U\Sigma</script><p>从而得出：</p>
<script type="math/tex; mode=display">A=U\Sigma V^T</script><h4 id="Step2-矩阵计算"><a href="#Step2-矩阵计算" class="headerlink" title="Step2:矩阵计算"></a>Step2:矩阵计算</h4><p>得到矩阵A的表示后，我们应该如何计算向量$U$和$V$呢？继续往下面分析：</p>
<p>首先计算出A的转置$A^T$：$A^T=V\Sigma ^TU^T$</p>
<script type="math/tex; mode=display">
A^TA=V\Sigma^TU^TU\Sigma V^T=V\Sigma^2V^T</script><p>利用上式可以得到，$A^TAv_i=\lambda_iv_i$，只需要求出$A^TA$的特征向量即可得到$V$.</p>
<p>同理可得$AA^T$的值：</p>
<script type="math/tex; mode=display">
AA^T=U\Sigma V^TV\Sigma^TU^T=U\Sigma^2U^T</script><p>可以得到$AA^Tu_i=\lambda_iu_i$，只需要求出$AA^T$的特征向量即可得到$U$.</p>
<blockquote>
<p>题外延伸——-矩阵(图像)压缩：</p>
<p>一个$m\times n$的矩阵A经SVD分解后，可以写成如下形式：</p>
<script type="math/tex; mode=display">
A_{m\times n}=U_{m\times m}\Sigma V^T_{n\times n}=(u_1,u_2,...,u_m)\begin{pmatrix}
    \lambda_1^{\frac{1}{2}}&&\\
    &\lambda_2^{\frac{1}{2}}&\\
    &&...
\end{pmatrix}\begin{pmatrix}
    v_1^T\\
    v_2^T\\
    ...\\
    v_n^T
\end{pmatrix}\\
=\lambda_1^{\frac{1}{2}}u_1v_1^T+\lambda_2^{\frac{1}{2}}u_2v_2^T+...</script><p>假设A为$m\times n$维矩阵，在没有压缩时表示矩阵A共需要$m\times n$个元素。如果将取得的特征值按从大到小排序，即$\lambda<em>1\geq\lambda_2\geq\lambda_3\geq…\geq\lambda</em>{min{m,n}}$，则A的压缩最小压缩表示为$\lambda_1^{\frac{1}{2}}u_1v_1^T$，即需要$m+n+1$个元素。<br>当压缩储存量为$(m+n+1)\times k$时，误差为</p>
<script type="math/tex; mode=display">
error=\frac{(m+n)\times\sum_{i=1}^{k}\lambda_i}{(m+n)\times\sum_{i=1}^{min(m,n)}\lambda_i}=\frac{\sum_{i=1}^{k}\lambda_i}{\sum_{i=1}^{min(m,n)}\lambda_i}</script></blockquote>
<h3 id="例题讲解"><a href="#例题讲解" class="headerlink" title="例题讲解"></a>例题讲解</h3><p>我们举一个简单的例子讲解矩阵时如何进行奇异值分解的。定义矩阵A为：</p>
<script type="math/tex; mode=display">
A=\begin{pmatrix}
0 &1 \\
1&1\\
1&0  
\end{pmatrix}</script><p>首先求出$A^TA、AA^T$：</p>
<script type="math/tex; mode=display">
A^TA=\begin{pmatrix}
    0&1&1\\
    1&1&0
\end{pmatrix}\begin{pmatrix}
    0&1\\
    1&1\\
    1&0
\end{pmatrix}=\begin{pmatrix}
    2&1\\
    1&2
\end{pmatrix}</script><script type="math/tex; mode=display">
AA^T=\begin{pmatrix}
    0&1\\
    1&1\\
    1&0
\end{pmatrix}\begin{pmatrix}
    0&1&1\\
    1&1&0
\end{pmatrix}=\begin{pmatrix}
    1&1&0\\
    1&2&1\\
    0&1&1
\end{pmatrix}</script><p>进而求出$A^TA$的特征值和特征向量：</p>
<script type="math/tex; mode=display">
\lambda_1=3;v_1=\begin{pmatrix}
    \frac{1}{\sqrt{2}}\\
    \frac{1}{\sqrt{2}}
\end{pmatrix};
\lambda_2=1;v_2=\begin{pmatrix}
    -\frac{1}{\sqrt{2}}\\
    \frac{1}{\sqrt{2}}
\end{pmatrix}</script><p>接着求出$AA^T$的特征值和特征向量：</p>
<script type="math/tex; mode=display">
\lambda_1=3;u_1=\begin{pmatrix}
    \frac{1}{\sqrt{6}}\\
    \frac{2}{\sqrt{6}}\\
    \frac{1}{\sqrt{6}}
\end{pmatrix};
\lambda_2=1;u_2=\begin{pmatrix}
    \frac{1}{\sqrt{2}}\\
    0\\
    -\frac{1}{\sqrt{2}}
\end{pmatrix};\lambda_3=0;u_3=\begin{pmatrix}
    \frac{1}{\sqrt{3}}\\
    -\frac{1}{\sqrt{3}}\\
    \frac{1}{\sqrt{3}}
\end{pmatrix}</script><p>利用$Av_i=\delta_iu_i,i=1,2$求奇异值：</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
    0&1\\
    1&1\\
    1&0
\end{pmatrix}\begin{pmatrix}
    \frac{1}{\sqrt{2}}\\
    \frac{1}{\sqrt{2}}
\end{pmatrix}=\delta_1\begin{pmatrix}
    \frac{1}{\sqrt{6}}\\
    \frac{2}{\sqrt{6}}\\
    \frac{1}{\sqrt{6}}
\end{pmatrix} \Rightarrow\delta_1=\sqrt{3}</script><script type="math/tex; mode=display">
\begin{pmatrix}
    0&1\\
    1&1\\
    1&0
\end{pmatrix}\begin{pmatrix}
    -\frac{1}{\sqrt{2}}\\
    \frac{1}{\sqrt{2}}
\end{pmatrix}=\delta_2\begin{pmatrix}
    \frac{1}{\sqrt{2}}\\
    0\\
    -\frac{1}{\sqrt{2}}
\end{pmatrix} \Rightarrow\delta_2=1</script><p>也可以用$\delta_i=\sqrt{\lambda_i}$直接求出奇异值为$\sqrt{3}$和$1$.</p>
<p>最终得到矩阵A的奇异值分解为：</p>
<script type="math/tex; mode=display">
A=U\Sigma V^T=\begin{pmatrix}
    \frac{1}{\sqrt{6}}  &\frac{1}{\sqrt{2}}  & \frac{1}{\sqrt{3}} \\
    \frac{2}{\sqrt{6}}  &0  & -\frac{1}{\sqrt{3}} \\
    \frac{1}{\sqrt{6}}  &-\frac{1}{\sqrt{2}}  & \frac{1}{\sqrt{3}} 
\end{pmatrix}\begin{pmatrix}
    \sqrt{3}  & 0\\
    0  & 1\\
    0  & 0
\end{pmatrix}\begin{pmatrix}
    \frac{1}{\sqrt{2}}  & \frac{1}{\sqrt{2}} \\
    -\frac{1}{\sqrt{2}}  & \frac{1}{\sqrt{2}}
\end{pmatrix}</script><h3 id="SVD的一些性质"><a href="#SVD的一些性质" class="headerlink" title="SVD的一些性质"></a>SVD的一些性质</h3><p>对于奇异值，他跟我们特征分解中的特征值类似，在奇艺置矩阵中也是按照从大到小排列，而且奇异值的减少特别快，在很多情况下，前10\%甚至1\%的奇异值就占了全部的奇异值之和的99\%以上的比例。也就是说，我们也可以用最大的k个奇异值和对应的左右奇异向量来近似描述矩阵(与前面描述的题外延伸之矩阵压缩类似)，由于这个重要的性质，SVD也可以用于PCA降维，来做数据压缩和去噪，也可以用于推荐算法，将用户和喜好对应的矩阵做特征分解，进而得到隐含的用户需要来做推荐。同时也可以用于NLP中的算法，比如潜在语义索引（LSI）。</p>
<blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/29846048" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29846048</a> </p>
<p>参考：<a href="https://www.csuldw.com/2017/03/09/2017-03-09-svd/" target="_blank" rel="noopener">https://www.csuldw.com/2017/03/09/2017-03-09-svd/</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/18/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC/" class="post-title-link" itemprop="url">反向传播算法推导</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 23:02:52" itemprop="dateCreated datePublished" datetime="2020-06-18T23:02:52+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-20 20:12:21" itemprop="dateModified" datetime="2020-06-20T20:12:21+08:00">2020-06-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="反向传播算法详细推导过程"><a href="#反向传播算法详细推导过程" class="headerlink" title="反向传播算法详细推导过程"></a><strong>反向传播算法详细推导过程</strong></h1><h2 id="1-前向传播"><a href="#1-前向传播" class="headerlink" title="1. 前向传播"></a><strong>1. 前向传播</strong></h2><p><img src="./images/feedfoward.jpg" alt></p>
<p>假设$X$为$N\times m$的矩阵（其中，$N$为样本个数（batch size），$m$为特征维数）</p>
<p>$h<em>1$与$Z_1$的维数为$m_1 \rightarrow W_1$为$m\times m_1$的矩阵，$b_1 \in \mathbb{R}^{m_1},\$<br>$h_2$与$Z_2$的维数为$m_2 \rightarrow W_2$为$m_1\times m_2$的矩阵，$b_2 \in \mathbb{R}^{m_2},\$<br>${\vdots}\$<br>$h_L$与$Z_L$的维数为$m_L \rightarrow W_L$为$m</em>{L-1}\times m_L$的矩阵，$b_L \in \mathbb{R}^{m_L}$</p>
<h3 id="前向算法："><a href="#前向算法：" class="headerlink" title="前向算法："></a>前向算法：</h3><script type="math/tex; mode=display">
\begin{array}{l}{h_{1}=x W_{1}+\tilde{b}_{1}, Z_{1}=f_{1}\left(h_{1}\right), \tilde{b}_{1}}为b_1^T沿着行方向扩展成N行 \\ {h_{2}=Z_{1} W_{2}+\tilde{b}_{2}, Z_{2}=f_{2}\left(h_{2}\right)} \\ {\vdots} \\ {h_{L}=Z_{L-1} W_{L}+\tilde{b}_{L}, Z_{L}=f_{L}\left(h_{L}\right)} \\ {\text { out }=Z_{L} W_{L+1}+\tilde{b}_{L+1}}\end{array}</script><p>假设输出为$n$维，则$out$为大小为$N\times n$的矩阵，根据MSE或CE准则可以求得$\frac{\partial J}{\partial out}$，对于回归问题与分类问题，$\frac{\partial J}{\partial out}$的求解方法如下：</p>
<table align="center">
    <tr>
        <td><center><img height="200" src="./images/回归问题.jpg">回归问题</center></td>
        <td><center><img height="200" src="./images/分类问题.jpg">分类问题</center></td>
    </tr>
</table>

<ul>
<li>对于回归问题，对out直接计算损失，损失函数为MSE。 损失：$J=\frac{1}{2N}\sum_{i=1}^{N}||y_i-\tilde{y_i}||^2$<script type="math/tex; mode=display">
\begin{aligned}
    \frac{\partial J}{\partial y_i}&=\frac{1}{2N}\sum_{i=1}^{N}(y_i-\tilde{y_i})\times 2 \\
    &=\frac{1}{N}\sum_{i=1}^{N}(y_i-\tilde{y_i})
\end{aligned}</script></li>
<li>对于分类问题，out后接softmax进行分类，然后使用CE(cross entropy)计算loss.$S<em>k=\frac{e^{y_k}}{\sum</em>{i=1}^{n}e^{y_i}}$一个样本对应的网络的输出$S(s_1,s_2,…,s_n)$是一个概率分布，而这个样本的标注$\tilde{S}$一般为$(0,0,…,1,0,0,…,0)$，也可以看做一个概率分布（硬分布）。cross entropy可以看成是$S$与$\tilde{S}$之间的KL距离：<script type="math/tex; mode=display">D(\tilde{S}||S)=\Sigma\tilde{S}\log\frac{\tilde{S}}{S}</script><ul>
<li>假设$\tilde{S}=(0,0,…,1,0,0,…,0)$，其中1为第$k$个元素(索引从0开始)，令$S=(s<em>0,s_1,…,s_k,…,s</em>{n-1})$.<br>损失：<script type="math/tex; mode=display">
\begin{aligned}
  J=D(\tilde{S}||S)&=1\times \log\frac{1}{s_k}\\&=-\log s_k \quad(CE损失函数,可看做目标类别概率最大)\\
  &=-\log\frac{e^{y_k}}{\sum_{i=0}^{n-1}e^{y_i}}
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
 &\frac{\partial J}{\partial y_m}=\frac{\partial J}{\partial y_m}(\log \sum_{i=0}^{n-1}e^{y_i}-y_k)=\frac{e^{y_m}}{\sum_{i=0}^{n-1}e^{y_i}}-\delta(m=k)=s_m-\delta(m=k) \\
&写成向量形式为:\frac{\partial J}{\partial y}=S-\tilde{S}
\end{aligned}</script></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>KL距离（相对熵）</strong>：是Kullback-Leibler Divergence的简称，也叫相对熵(Relative Entropy).它衡量的是相同事件空间里的两个概率分布的差异情况。其物理意义是：在相同事件空间里，概率分布$P(x)$对应的每个事件，若用概率分布$Q(x)$编码时，平均每个基本事件(符号)编码长度增加了多少比特。我们用$D(P||Q)$表示KL距离，计算公式如下：</p>
<script type="math/tex; mode=display">
D(P||Q)=\sum_{x\in X}P(x)\log\frac{P(x)}{Q(x)}</script><p>当两个概率分布完全相同时，即$P(X)=Q(X)$,其相对熵为0.</p>
<h2 id="2-反向传播"><a href="#2-反向传播" class="headerlink" title="2.反向传播"></a><strong>2.反向传播</strong></h2><p>$\text { out }=Z<em>{L} W</em>{L+1}+\tilde{b}<em>{L+1}$，为了便于详细说明反向传播算法，假设$Z_L$为$2\times 3$的向量，$W</em>{L+1}$为$3\times 2$的向量：</p>
<script type="math/tex; mode=display">
\begin{array}{l}{Z_{L}=\left(\begin{array}{ccc}{z_{11}} & {z_{12}} & {z_{13}} \\ {z_{21}} & {z_{22}} & {z_{23}}\end{array}\right)_{2 \times 3}, W_{L+1}=\left(\begin{array}{cc}{w_{11}} & {w_{12}} \\ {w_{21}} & {w_{22}} \\ {w_{31}} & {w_{32}}\end{array}\right)_{3 \times 2} \tilde{b}_{L+1}=\left(\begin{array}{cc}{b_{1}} & {b_{2}} \\ {b_{1}} & {b_{2}}\end{array}\right)_{2 \times 2}, \text { out }=\left(\begin{array}{cc}{o_{11}} & {o_{12}} \\ {o_{21}} & {o_{22}}\end{array}\right)} \\ \Rightarrow  {Z_{L}W_{L+1}+\tilde{b}_{L+1}=\left(\begin{array}{cc}{z_{11} w_{11}+z_{12} w_{21}+z_{13} w_{31}+b_1} & {z_{11} w_{12}+z_{12} w_{22}+z_{13} w_{32}+b_2} \\ {z_{21} w_{11}+z_{22} w_{21}+z_{23} w_{31}+b_1} & {z_{21} w_{12}+z_{22} w_{22}+z_{23} w_{32}+b_2}\end{array}\right)=\text{out}.}\end{array}</script><p>所以，</p>
<script type="math/tex; mode=display">
\begin{array}{l}{o_{11}=z_{11} w_{11}+z_{12} w_{21}+z_{13} w_{31}+b_{1}} \\ {o_{12}=z_{11} w_{12}+z_{12} w_{22}+z_{13} w_{32}+b_{2}} \\ {o_{21}=z_{21} w_{11}+z_{22} w_{21}+z_{23} w_{31}+b_{1}} \\ {o_{22}=z_{21} w_{12}+z_{22} w_{22}+z_{23} w_{32}+b_{2}}\end{array}</script><h4 id="1-损失-J-对-W-的导数："><a href="#1-损失-J-对-W-的导数：" class="headerlink" title="1) 损失$J$对$W$的导数："></a><strong>1) 损失$J$对$W$的导数：</strong></h4><script type="math/tex; mode=display">
\begin{aligned} \frac{\partial J}{\partial w_{11}} &=\frac{\partial J}{\partial o_{11}} z_{11}+\frac{\partial J}{\partial o_{21}} z_{21}, \frac{\partial J}{\partial w_{12}}=\frac{\partial J}{\partial o_{12}} z_{11}+\frac{\partial J}{\partial o_{22}} z_{21} \\ \frac{\partial J}{\partial w_{21}} &=\frac{\partial J}{\partial o_{11}} z_{12}+\frac{\partial J}{\partial o_{21}} z_{22}, \frac{\partial J}{\partial w_{22}}=\frac{\partial J}{\partial o_{12}} z_{12}+\frac{\partial J}{\partial o_{22}} z_{22} \\ \frac{\partial J}{\partial w_{31}} &=\frac{\partial J}{\partial o_{11}} z_{13}+\frac{\partial J}{\partial o_{21}} z_{23}, \frac{\partial J}{\partial w_{32}}=\frac{\partial J}{\partial o_{12}} z_{13}+\frac{\partial J}{\partial o_{22}} z_{23} \end{aligned}</script><script type="math/tex; mode=display">
\Rightarrow
\left(\begin{array}{cc}{\frac{\partial J}{\partial w_{11}}} & {\frac{\partial J}{\partial w_{12}}} \\ {\frac{\partial J}{\partial w_{21}}} & {\frac{\partial J}{\partial w_{22}}} \\ {\frac{\partial J}{\partial w_{31}}} & {\frac{\partial J}{\partial w_{32}}}\end{array}\right)=\left(\begin{array}{cc}{z_{11}} & {z_{21}} \\ {z_{12}} & {z_{22}} \\ {z_{13}} & {z_{23}}\end{array}\right)\left(\begin{array}{cc}{\frac{\partial J}{\partial o_{11}}} & {\frac{\partial J}{\partial o_{12}}} \\ {\frac{\partial J}{\partial o_{21}}} & {\frac{\partial J}{\partial o_{22}}}\end{array}\right)</script><p>即，$\frac{\partial J}{\partial W_{L+1}}=Z_L^T\frac{\partial J}{\partial out}$</p>
</blockquote>
<h4 id="2-损失对偏置b的导数等于将-frac-partial-J-partial-out-的每一列加起来："><a href="#2-损失对偏置b的导数等于将-frac-partial-J-partial-out-的每一列加起来：" class="headerlink" title="2) 损失对偏置b的导数等于将$\frac{\partial J}{\partial out}$的每一列加起来："></a><strong>2) 损失对偏置b的导数等于将$\frac{\partial J}{\partial out}$的每一列加起来：</strong></h4><script type="math/tex; mode=display">
\left\{\begin{array}{l}{\frac{\partial J}{\partial b_{1}}=\frac{\partial J}{\partial o_{11}}+\frac{\partial J}{\partial o_{21}}} \\ {\frac{\partial J}{\partial b_{2}}=\frac{\partial J}{\partial o_{12}}+\frac{\partial J}{\partial o_{22}}}\end{array} \Rightarrow\left(\frac{\partial J}{\partial b_{L+1}}\right)^{T}=\left(\frac{\partial J}{\partial b_{1}} \quad \frac{\partial J}{\partial b_{2}}\right)=\left(\frac{\partial J}{\partial o_{11}}+\frac{\partial J}{\partial o_{21}} \quad \frac{\partial J}{\partial o_{12}}+\frac{\partial J}{\partial o_{22}}\right)\right.</script><h4 id="3-损失-J-对-Z-的导数："><a href="#3-损失-J-对-Z-的导数：" class="headerlink" title="3) 损失$J$对$Z$的导数："></a><strong>3) 损失$J$对$Z$的导数：</strong></h4><script type="math/tex; mode=display">
\begin{aligned} \frac{\partial J}{\partial z_{11}} &=\frac{\partial J}{\partial o_{11}} w_{11}+\frac{\partial J}{\partial o_{12}} w_{12} ; \frac{\partial J}{\partial z_{12}}=\frac{\partial J}{\partial o_{11}} w_{21}+\frac{\partial J}{\partial o_{12}} w_{22} ; \frac{\partial J}{\partial z_{13}}=\frac{\partial J}{\partial o_{11}} w_{31}+\frac{\partial J}{\partial o_{12}} w_{32} \\ \frac{\partial J}{\partial z_{21}} &=\frac{\partial J}{\partial o_{21}} w_{11}+\frac{\partial J}{\partial o_{22}} w_{12} ; \frac{\partial J}{\partial z_{22}}=\frac{\partial J}{\partial o_{21}} w_{21}+\frac{\partial J}{\partial o_{12}} w_{22} ; \frac{\partial J}{\partial z_{23}}=\frac{\partial J}{\partial o_{21}} w_{31}+\frac{\partial J}{\partial o_{22}} w_{32} \end{aligned}</script><p>即，</p>
<script type="math/tex; mode=display">
\left(\begin{array}{ccc}{\frac{\partial J}{\partial z_{11}}} & {\frac{\partial J}{\partial z_{12}}} & {\frac{\partial J}{\partial z_{13}}} \\ {\frac{\partial J}{\partial z_{21}}} & {\frac{\partial J}{\partial z_{22}}} & {\frac{\partial J}{\partial z_{23}}}\end{array}\right)=\left(\begin{array}{cc}{\frac{\partial J}{\partial o_{11}}} & {\frac{\partial J}{\partial o_{12}}} \\ {\frac{\partial J}{\partial \theta_{21}}} & {\frac{\partial J}{\partial o_{22}}}\end{array}\right)\left(\begin{array}{ccc}{w_{11}} & {w_{21}} & {w_{31}} \\ {w_{12}} & {w_{22}} & {w_{32}}\end{array}\right)</script><p>$\Rightarrow \frac{\partial J}{\partial Z<em>{L}}=\frac{\partial J}{\partial out}W</em>{L+1}^T$</p>
<h4 id="4-损失-J-对-h-的导数："><a href="#4-损失-J-对-h-的导数：" class="headerlink" title="4) 损失$J$对$h$的导数："></a><strong>4) 损失$J$对$h$的导数：</strong></h4><script type="math/tex; mode=display">Z_L = f_L(h_L)</script><ul>
<li>$f_L$为sigmoid时，$Z_L=\frac{1}{1+e^{-h_L}}$.<script type="math/tex; mode=display">
\begin{array}{l}{\frac{\partial J}{\partial h_{L}}=\frac{\partial J}{\partial Z_{L}} \frac{d z_{L}}{d h_{L}}=\frac{\partial J}{\partial Z_{L}} \frac{e^{-h L}}{\left(1+e^{-h_{L}}\right)^{2}}=\frac{\partial J}{\partial Z_{L}} \frac{1}{1+e^{-h_{L}}} \frac{e^{-h_{L}}}{1+e^{-h_{L}}}} \\ {=\frac{\partial J}{\partial Z_{L}} Z_{L}\left(1-Z_{L}\right)}\end{array}</script></li>
<li>$f<em>L$为tanh时，${Z</em>{L}=\frac{e^{h<em>{L}}-e^{-h</em>{L}}}{e^{h<em>{L}}+e^{-h</em>{L}}}}$.<script type="math/tex; mode=display">
\begin{array}{l} {\frac{\partial J}{\partial h_{L}}=\frac{\partial J}{\partial Z_{L}} \frac{d Z_{L}}{d h_{L}}=\frac{\partial J}{\partial Z_{L}} \frac{4}{\left(e^{h_{L}}+e^{-h_{L}}\right)^{2}}=\frac{\partial J}{\partial Z_{L}}\left[1-\left(\frac{e^{h_{L}}-e^{-h_{L}}}{e^{h_{L}}+e^{-h_{L}}}\right)^{2}\right]} \\ {=\frac{\partial J}{\partial z_{L}}\left[1-z_{L}^{2}\right]}\end{array}</script></li>
<li>$f_L$为relu时，$Z_L=relu(h_L)=\left{\begin{matrix}<br>0,&amp;h_L\leq 0 \<br>h_L,&amp;h_L &gt; 0<br>\end{matrix}\right.$.<script type="math/tex; mode=display">
\begin{array}{l}
  \frac{\partial J}{\partial h_L}=\frac{\partial J}{\partial Z_L}\frac{\partial Z_L}{\partial h_L}=\left\{\begin{matrix}
0,&h_L\leq 0 \\ 
\frac{\partial J}{\partial Z_L},&h_L > 0 
\end{matrix}\right.
\end{array}</script></li>
</ul>
<h2 id="3-梯度更新"><a href="#3-梯度更新" class="headerlink" title="3. 梯度更新"></a><strong>3. 梯度更新</strong></h2><p>对于不同算法 ，梯度更新方式如下：</p>
<script type="math/tex; mode=display">
\frac{\partial J}{\partial out} \Rightarrow \left \{\begin{matrix}
    \frac{\partial J}{\partial W_{L+1}}=Z_L^T\frac{\partial J}{\partial out} \\
    \frac{\partial J}{\partial Z_{L}}=\frac{\partial J}{\partial out}W_{L+1}^T \\
    \left(\frac{\partial J}{\partial b}\right)^{T}=SumCol(\frac{\partial J}{\partial out}) \\
    W_{L+1}^{t+1} = W_{L+1}^t-\eta \frac{\partial J}{\partial W_{L+1}} \\
    b_{L+1}^{t+1} = b_{L+1}^t-\eta \frac{\partial J}{\partial b_{L+1}}
\end{matrix} \right. \Rightarrow \frac{\partial J}{\partial h_L}=\frac{\partial J}{\partial Z_L}\frac{\partial Z_L}{\partial h_L} \Rightarrow \left \{\begin{matrix} 
    \frac{\partial J}{\partial W_{L}}=Z_{L-1}^T\frac{\partial J}{\partial h_L} \\
    \frac{\partial J}{\partial Z_{L-1}}=\frac{\partial J}{\partial h_L}W_{L}^T \\
    \vdots \\
    \vdots 
\end{matrix}\right. \Rightarrow \cdots</script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">深度学习中的模型优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 23:02:52" itemprop="dateCreated datePublished" datetime="2020-06-18T23:02:52+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-20 20:12:21" itemprop="dateModified" datetime="2020-06-20T20:12:21+08:00">2020-06-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深度学习中的模型优化"><a href="#深度学习中的模型优化" class="headerlink" title="深度学习中的模型优化"></a>深度学习中的模型优化</h1><h2 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h2><h3 id="Batch-Gradient-Descent-BGD"><a href="#Batch-Gradient-Descent-BGD" class="headerlink" title="Batch Gradient Descent(BGD)"></a>Batch Gradient Descent(BGD)</h3><p>BGD在训练中,每一步迭代都是用训练集中的所有数据,也就是说,利用现有参数对训练集中的每一个输入生成一个估计输出,然后跟实际输出比较,统计所有误差,求平均以后得到平均误差,并以此作为更新参数的依据.</p>
<ul>
<li><strong>优点:</strong> 由于每一步都利用了训练集中的所有数据,因此当损失函数达到最小值以后,能够保证此时计算出的梯度为0,换句话说,就是能够收敛(曲线比较平滑),因此,使用BGD时不需要逐渐降低学习率.</li>
<li><strong>缺点:</strong> 由于每一步都要用到所有训练数据,因此随着数据集的增大,运行速度会越来越慢.<h3 id="SGD与MBGD"><a href="#SGD与MBGD" class="headerlink" title="SGD与MBGD"></a>SGD与MBGD</h3>MBGD是指在训练中,每次使用小批量(一个小批量训练m个样本)的随机采样进行梯度下降.训练方法与BGD一样,只是BGD最后对训练集的所有样本取平均,而MBGD只对小批量的m个样本取平均.SGD是指在训练中每次仅使用一个样本.MBGD与SGD统称为SGD.因为小批量不能代表整个训练集,使得梯度估计引入噪声源,因此SGD并不是每次迭代都向着整体最优化方向.虽然SGD包含一定的随机性(表现为损失函数的震荡),但是从期望来看,它是等于正确的导数的(表现为损失函数有减小的趋势).</li>
<li><strong>优点:</strong> 训练速度比较快</li>
<li><strong>缺点:</strong> 在样本数量较大的情况下,可能只用到了其中一部分数据就完成了训练,得到的只是局部最优解.另外,小批量样本的噪声较大,所以每次执行梯度下降,并不一定总是朝着最优的方向前进.<br><img src="./images/SGD与BGD.png" alt><h3 id="参数更新"><a href="#参数更新" class="headerlink" title="参数更新"></a>参数更新</h3><script type="math/tex; mode=display">\left \{
\begin{array}{l}{\boldsymbol{v}_{t}=-\eta \triangledown_\theta J\left(\boldsymbol{\theta}_{t}\right) } \\ {\boldsymbol{\theta}_{t} =\boldsymbol{\theta}_{t-1}+\boldsymbol{v}_{t}}\end{array} \right.</script>其中，$\eta$代表学习率，$\theta<em>t$表示$t$时刻的参数，$\triangledown </em>\theta J(\theta_t)$代表参数$\theta$在$t$时刻的导数，$v_t$代表参数的更新速度。<h2 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h2>在训练中，采取的策略与SGD一样，不同的是学习率的更新方式。动量的参数更新方式为：<script type="math/tex; mode=display">\left \{
\begin{array}{l}{\boldsymbol{v}_{t}=-\eta \triangledown_\theta J\left(\boldsymbol{\theta}_{t}\right)+\alpha \boldsymbol{v}_{t-1}} \\ {\boldsymbol{\theta}_{t+1} =\boldsymbol{\theta}_{t}+\boldsymbol{v}_{t}}\end{array} \right.</script>$\alpha$一般取值0.9.</li>
</ul>
<p>直观理解为：<br><img src="./images/momentum.jpg" alt><br>动量方法旨在加速学习（加快梯度的下降速度），特别是处理高曲率、小但一致的梯度，或是带噪声的梯度。动量算法累积了之前梯度指数级衰减的移动平均，并且继续沿该方向移动。</p>
<table align="center">
    <tr>
        <td><center><img height="200" width="300" src="./images/momentum.gif"></center></td>
    </tr>
</table>

<p>动量SGD算法引入$\alpha \boldsymbol{v}_{t-1}$使每一次的参数更新方向不仅仅取决于当前位置的梯度，还受到上一次参数更新方向的影响（如上图所示）。在某一维度上，当梯度方向不变时，更新速度变快，当梯度方向有所改变时，更新速度变慢，从而加快收敛速度，减少震荡。</p>
<p>带有动量的SGD的优点：</p>
<ul>
<li>加快收敛速度</li>
<li>抑制梯度下降时上下震荡的情况</li>
<li>通过局部极小点</li>
</ul>
<blockquote>
<p>分析：假设任意时刻参数的梯度均为$g<em>t=\triangledown</em>\theta J\left(\boldsymbol{\theta}_{t}\right)=g_0$，则使用SGD时,$t$时刻的梯度$g^{SGD}_t=g_0$,Momentum算法的梯度$g^{mom}_t=(\alpha^{t-1}+\alpha^{t-2}+…+\alpha+1)g_0=\frac{1-\alpha^{t}}{1-\alpha}g_0$.当$t\rightarrow +\infty$，因$\alpha&lt;1$,所以$\alpha^t\rightarrow 0$,所以$g_t^{mom}\rightarrow \frac{1}{1-\alpha}g_0$,当$\alpha=0.9$时，Momentum更新速度是SGD的10倍</p>
</blockquote>
<h2 id="Nesterov-NAG"><a href="#Nesterov-NAG" class="headerlink" title="Nesterov(NAG)"></a>Nesterov(NAG)</h2><p>Nesterov动量是Momentum的变种，即在计算参数梯度之前，前瞻一步，超前一个动量单位处：$\theta<em>t + \gamma v</em>{t-1}$,Nesterov动量可以理解为往Momentum动量中加入了一个校正因子。参数更新公式为：</p>
<script type="math/tex; mode=display">\left \{
\begin{array}{l}{\boldsymbol{v}_{t}=-\eta \triangledown_\theta J\left(\boldsymbol{\theta}_{t}+\gamma \boldsymbol{v}_{t-1}\right)+\alpha \boldsymbol{v}_{t-1}} \\ {\boldsymbol{\theta}_{t+1} =\boldsymbol{\theta}_{t}+\boldsymbol{v}_{t}}\end{array} \right.</script><p>Momentum动量与Nesterov动量的对比如下图所示，其中$\eta \triangledown<em>1$代表A节点 ($\theta_t$)的梯度，$\eta \triangledown_2$代表B节点($\theta</em>{t}+\gamma \boldsymbol{v}<em>{t-1}$的梯度)，灰色实线代表$t-1$时刻的速度$\alpha v</em>{t-1}$.</p>
<table align="center">
    <tr>
        <td><center><img height="230" width="250" src="./images/nesterov.png"></center></td>
        <td><center><img height="230" width="300" src="./images/nesterov.bmp"></center></td>
    </tr>
</table>

<blockquote>
<p>注意：图中的$\eta \triangledown_1以及\eta \triangledown_2$应该为$-\eta \triangledown_1$、$-\eta \triangledown_2$因为梯度方向是增长速度最快的方向，而图中所示为梯度的反方向，所以应该为$-\eta \triangledown_1$、$-\eta \triangledown_2$.</p>
</blockquote>
<p>Nesterov动量相对于Momentum多了一个本次梯度相对上次梯度的变化量，这个变化量本质上是对目标函数二阶导的近似，由于令了二阶导的信息，Nesterov动量算法才会比Momentum具有更快的收敛速度。</p>
<h2 id="AdaGrad"><a href="#AdaGrad" class="headerlink" title="AdaGrad"></a>AdaGrad</h2><p>AdaGrad其实是对学习率进行了约束，AdaGrad独立地适应所有模型参数的学习率，缩放每个参数反比于其它所有梯度历史平方值总和的平方根。损失较大偏导的参数相应地拥有一个快速下降的学习率，而较小偏导的参数在学习率上有相对较小的下降。净效果是在参数空间中更为平缓的倾斜方向会取得更大的进步。参数更新公式为：</p>
<script type="math/tex; mode=display">\left \{
\begin{array}{l}{
    g_t=\triangledown_\theta J(\theta_t)}\\
    {n_t=n_{t-1}+g_t^2} \\
    {\boldsymbol{v}_{t}=-\frac{\eta}{\sqrt{n_t+\epsilon}}g_t } \\ {\boldsymbol{\theta}_{t+1} =\boldsymbol{\theta}_{t}+\boldsymbol{v}_{t}}\end{array} \right.</script><p>其中，$\epsilon$是个很小的数，用来保证分母非0。对$𝑔_𝑡$从1到t进行一个递推形成一个约束项regularizer——-$\frac{1}{\sqrt{n_t+\epsilon}}$。</p>
<p><strong>优点：</strong><br>前期$g_t$较小的时候， $\frac{1}{\sqrt{n_t+\epsilon}}$较大，梯度更新较大，可以解决SGD中学习率一直不变的问题;后期$g_t$较大的时候，$\frac{1}{\sqrt{n_t+\epsilon}}$较小，能够约束梯度.适合处理稀疏梯度.</p>
<p><strong>缺点：</strong><br>由公式可以看出，AdaGrad依赖于人工设置一个全局学习率𝜂，当$\eta$设置过大时，使regularizer过于敏感，对梯度的调节太大。在中后期，分母上梯度平方的累加将会越来越大，gradient→0，网络的更新能力会越来越弱，学习率会变的极小，使得训练提前结束。为了解决这样的问题，又提出了Adadelta算法。</p>
<h2 id="Adadelta"><a href="#Adadelta" class="headerlink" title="Adadelta"></a>Adadelta</h2><p>Adadelta是对AdaGrad的扩展，AgaGrad会累加所有历史梯度的平方，而Adadelta只累加固定大小的项，并且也不直接存储这些项，仅仅是近似计算对应的平均值。参数更新方式为：</p>
<script type="math/tex; mode=display">\left \{
\begin{array}{l}{
    g_t=\triangledown_\theta J(\theta_t)}\\
    {n_t=\gamma n_{t-1}+(1-\gamma)g_t^2}\\
    {\boldsymbol{v}_{t}=-\frac{\eta}{\sqrt{n_t+\epsilon}}g_t } \\ {\boldsymbol{\theta}_{t+1} =\boldsymbol{\theta}_{t}+\boldsymbol{v}_{t}}\end{array} \right.</script><p>但是，此时Adadelta其实仍然依赖于全局学习率，因此，又做了一些处理，新的参数更新方式为：</p>
<script type="math/tex; mode=display">\left \{
\begin{array}{l}{
    g_t=\triangledown_\theta J(\theta_t)}\\
    {E|g^2|_t=\rho \times E|g^2|_{t-1}+(1-\rho)\times g_t^2}\\
    {v_t=-\frac{\sqrt{\sum_{r=1}^{t-1}}v_r}{\sqrt{E|t^2|_t+\epsilon}}g_t}\\
    {\boldsymbol{\theta}_{t+1} =\boldsymbol{\theta}_{t}+\boldsymbol{v}_{t}}\end{array} \right.</script><p>新的参数更新方式，不依赖于全局学习率，并且，训练初中期，加速效果不错，很快；训练后期，反复在局部最小值附近抖动。</p>
<h2 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h2><p>RMSprop可以算作Adadelta的一个特例：当$\rho=0.5$时，$E|g^2|<em>t=\rho \times E|g^2|</em>{t-1}+(1-\rho)\times g_t^2$就变为了求梯度平方和的平均数。</p>
<p>如果再求根的话，就变成了RMS(均方根)：$RMS|g|_t=\sqrt{E|g^2|_t+\epsilon}$。RMSprop的参数更新方式为：</p>
<script type="math/tex; mode=display">\left \{
\begin{array}{l}{
    g_t=\triangledown_\theta J(\theta_t)}\\
    {E|g^2|_t=\rho \times E|g^2|_{t-1}+(1-\rho)\times g_t^2} \\
    {RMS|g|_t=\sqrt{E|g^2|_t+\epsilon}}\\
    {\boldsymbol{v}_{t}=-\frac{\eta}{RMS|g|_t }g_t} \\ {\boldsymbol{\theta}_{t+1} =\boldsymbol{\theta}_{t}+\boldsymbol{v}_{t}}\end{array} \right.</script><p><strong>特点：</strong> (1)RMSprop依然依赖于全局学习率;(2)RMSprop算是Adagrad的一种发展，和Adadelta的变体，效果趋于二者之间;(3)适合处理非平稳目标 - 对于RNN效果很好</p>
<h2 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h2><p>Adam优化器结合了AdaGrad与RMSProp两种算法的优点。对梯度的一阶距估计$m_t$（即梯度的均值）和二阶距估计$n_t$（即梯度的未中心化的方差）进行综合考虑，计算出更新步长。更新方式为：</p>
<script type="math/tex; mode=display">\left \{
\begin{array}{l}{
    g_t=\triangledown_\theta J(\theta_t)}\\
    {m_t=\beta_1m_{t-1}+(1-\beta_1)g_t}\\
    {v_t=\beta_2v_{t-1}+(1-\beta_2)g_t^2}\\
    {\hat{m_t}=\frac{m_t}{1-\beta_1^t}}\\
    {\hat{v}_t=\frac{v_t}{1-\beta_2^t}}\\
    {\boldsymbol{\theta}_{t+1}=\boldsymbol{\theta}_{t}-\frac{\eta}{\sqrt{\hat{v}_t+\epsilon}}\hat{m}_t}\\
\end{array} \right.</script><blockquote>
<p>注：所有的$t$均表示$t$时刻。$m_t$、$n_t$分别是梯度的一阶距估计和二阶距估计，可以看做是对期望$E|g_t|、E|g_t^2|$的估计；$\hat{m}_t、\hat{n}_t$是对$m_t$、$n_t$的校正，这样可以近似为对期望的无偏估计。</p>
</blockquote>
<p><strong>优点：</strong></p>
<ol>
<li>实现简单，计算高效，对内存需求少</li>
<li>参数的更新不受梯度的伸缩变换影响</li>
<li>超参数具有很好的解释性，且通常无需调整或仅需很少的微调</li>
<li>更新的步长能够被限制在大致的范围内（初始学习率）</li>
<li>能自然地实现步长退火过程（自动调整学习率）</li>
<li>很适合应用于大规模的数据及参数的场景</li>
<li>适用于不稳定目标函数</li>
<li>适用于梯度稀疏或梯度存在很大噪声的问题</li>
</ol>
<blockquote>
<p>参考资料：</p>
<p><a href="https://zhuanlan.zhihu.com/p/73264637" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73264637</a> </p>
<p><a href="https://zhuanlan.zhihu.com/p/60088231" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60088231</a></p>
<p><a href="https://blog.csdn.net/u012759136/article/details/52302426" target="_blank" rel="noopener">https://blog.csdn.net/u012759136/article/details/52302426</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenzhongyao.github.io/2020/06/18/%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E5%88%B7%E8%BF%87%E7%9A%84%E5%89%91%E6%8C%87offer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="chennan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenzhongyao's website">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E5%88%B7%E8%BF%87%E7%9A%84%E5%89%91%E6%8C%87offer/" class="post-title-link" itemprop="url">那些年，刷过的剑指offer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-18 23:02:52" itemprop="dateCreated datePublished" datetime="2020-06-18T23:02:52+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-20 20:12:21" itemprop="dateModified" datetime="2020-06-20T20:12:21+08:00">2020-06-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-连续子数组的最大和"><a href="#1-连续子数组的最大和" class="headerlink" title="1. 连续子数组的最大和"></a>1. 连续子数组的最大和</h3><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mx = INT_MIN;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty()) <span class="keyword">return</span> mx;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">array</span>.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cur += <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="keyword">if</span>(cur &gt; mx)</span><br><span class="line">                mx = cur;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur &lt;= <span class="number">0</span>)</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-第N个丑数"><a href="#2-第N个丑数" class="headerlink" title="2. 第N个丑数"></a>2. 第N个丑数</h3><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">7</span>) <span class="keyword">return</span> index;    <span class="comment">//小于7时为其本身</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>, p3 = <span class="number">0</span>, p5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minNum = <span class="number">1</span>;</span><br><span class="line">        nums.push_back(minNum);</span><br><span class="line">        <span class="keyword">while</span>(nums.<span class="built_in">size</span>()&lt;index)</span><br><span class="line">        &#123;</span><br><span class="line">            minNum = <span class="built_in">min</span>(nums[p2]*<span class="number">2</span>, <span class="built_in">min</span>(nums[p3]*<span class="number">3</span>, nums[p5]*<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span>(minNum == nums[p2]*<span class="number">2</span>)</span><br><span class="line">                p2++;</span><br><span class="line">            <span class="keyword">if</span>(minNum == nums[p3]*<span class="number">3</span>)</span><br><span class="line">                p3++;</span><br><span class="line">            <span class="keyword">if</span>(minNum == nums[p5]*<span class="number">5</span>)</span><br><span class="line">                p5++;</span><br><span class="line">            nums.push_back(minNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-第一个出现一次的字符"><a href="#3-第一个出现一次的字符" class="headerlink" title="3. 第一个出现一次的字符"></a>3. 第一个出现一次的字符</h3><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">char</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">                mp[str[i]]++;   <span class="comment">//map貌似可以直接这样，不用考虑当key不存在时的情况，应该会默认创建</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[str[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-数组中的逆序对"><a href="#4-数组中的逆序对" class="headerlink" title="4. 数组中的逆序对"></a>4. 数组中的逆序对</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.empty()) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;copy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.<span class="built_in">size</span>();i++)</span><br><span class="line">           copy.push_back(data[i]);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> count = help(data, copy, <span class="number">0</span>, data.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> count % <span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;data, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;copy, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == <span class="built_in">end</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            copy[start] = data[start];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (<span class="built_in">end</span> - start) / <span class="number">2</span> + start;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> left = help(copy, data, start, mid);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> right = help(copy, data, mid+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">int</span> i = mid, j = <span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=start &amp;&amp; j&gt;=mid+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i] &gt; data[j])</span><br><span class="line">            &#123;</span><br><span class="line">                copy[index--] = data[i--];</span><br><span class="line">                count += j - (mid + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                copy[index--] = data[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; i&gt;=start; i--)</span><br><span class="line">            copy[index--] = data[i];</span><br><span class="line">        <span class="keyword">for</span>(; j&gt;=mid+<span class="number">1</span>; j--)</span><br><span class="line">            copy[index--] = data[j];</span><br><span class="line">        <span class="keyword">return</span> left + right + count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5-两个链表的公共子节点"><a href="#5-两个链表的公共子节点" class="headerlink" title="5. 两个链表的公共子节点"></a>5. 两个链表的公共子节点</h3><p>输入两个链表，找出它们的第一个公共结点。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span>：首先遍历每个链表求其长度len1, len2，然后使长的链表先走<span class="built_in">abs</span>(len1-len2),之后再一起走，第一个相同的节点就是第一个公共子节点</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead1 || !pHead2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">        ListNode* ptr1 = pHead1, *ptr2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(ptr1)</span><br><span class="line">        &#123;</span><br><span class="line">            len1++;</span><br><span class="line">            ptr1 = ptr1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ptr2)</span><br><span class="line">        &#123;</span><br><span class="line">            len2++;</span><br><span class="line">            ptr2 = ptr2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr1 = pHead1, ptr2 = pHead2;</span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len1-len2; i++)</span><br><span class="line">                ptr1 = ptr1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len2-len1; i++)</span><br><span class="line">                ptr2 = ptr2-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(ptr1!=ptr2)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr1 = ptr1-&gt;next;</span><br><span class="line">            ptr2 = ptr2-&gt;next;</span><br><span class="line">        &#125;a</span><br><span class="line">        <span class="keyword">return</span> ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">方法<span class="number">2</span>：双指针法，两个指针p1, p2分别指向两个链表的头节点pHead1, pHead2，当一个指针p1走到末尾时，使p1接着指向pHead2,当指针p2走到末尾时，使p2接着指向pHead1，直到两者相等。</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead1 || !pHead2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* ptr1 = pHead1, *ptr2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(ptr1 != ptr2)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr1 = ptr1==<span class="literal">NULL</span>?pHead2:ptr1-&gt;next;</span><br><span class="line">            ptr2 = ptr2==<span class="literal">NULL</span>?pHead1:ptr2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-数字在排序数组中出现的次数"><a href="#6-数字在排序数组中出现的次数" class="headerlink" title="6. 数字在排序数组中出现的次数"></a>6. 数字在排序数组中出现的次数</h3><p>统计一个数字在排序数组中出现的次数（二分查找法实现logn）</p>
<p>来自 <a href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&amp;tqId=11190&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&amp;tqId=11190&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = data.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = getFirstKIndex(data, <span class="number">0</span>, len<span class="number">-1</span>, k);</span><br><span class="line">        <span class="keyword">int</span> right = getLastKIndex(data, <span class="number">0</span>, len<span class="number">-1</span>, k);</span><br><span class="line">        <span class="keyword">if</span>(left&gt;<span class="number">-1</span> &amp;&amp; right&gt;<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFirstKIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;data, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; <span class="built_in">end</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (<span class="built_in">end</span> - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data[mid]==k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid==start || data[mid<span class="number">-1</span>] != data[mid])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">end</span> = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data[mid]&gt;k)</span><br><span class="line">            <span class="built_in">end</span> = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getFirstKIndex(data, start, <span class="built_in">end</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLastKIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;data, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;<span class="built_in">end</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (<span class="built_in">end</span> - start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(data[mid]==k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid == <span class="built_in">end</span> || data[mid+<span class="number">1</span>]!=data[mid])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(data[mid]&gt;k)</span><br><span class="line">            <span class="built_in">end</span> = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getLastKIndex(data, start, <span class="built_in">end</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="7-求二叉树的深度"><a href="#7-求二叉树的深度" class="headerlink" title="7. 求二叉树的深度"></a>7. 求二叉树的深度</h3><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&amp;tqId=11191&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&amp;tqId=11191&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lf = TreeDepth(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rg = TreeDepth(pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> lf&gt;rg?lf+<span class="number">1</span>:rg+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="8-平衡二叉树"><a href="#8-平衡二叉树" class="headerlink" title="8. 平衡二叉树"></a>8. 平衡二叉树</h3><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span>：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> lf = TreeHeight(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rg = TreeHeight(pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">bool</span> left = IsBalanced_Solution(pRoot-&gt;left);</span><br><span class="line">        <span class="keyword">bool</span> right = IsBalanced_Solution(pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(lf-rg)&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">TreeHeight</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lf = TreeHeight(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rg = TreeHeight(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> lf&gt;rg?lf+<span class="number">1</span>:rg+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">方法<span class="number">2</span>：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> balanced(pRoot, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">balanced</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        &#123;</span><br><span class="line">            depth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lf, rg;</span><br><span class="line">        <span class="keyword">bool</span> left = balanced(root-&gt;left, lf);</span><br><span class="line">        <span class="keyword">bool</span> right = balanced(root-&gt;right, rg);</span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right &amp;&amp; <span class="built_in">abs</span>(lf-rg)&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            depth = <span class="built_in">max</span>(lf, rg) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="9-和为S的连续正数序列"><a href="#9-和为S的连续正数序列" class="headerlink" title="9. 和为S的连续正数序列"></a>9. 和为S的连续正数序列</h3><p>题目描述<br>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!<br>输出描述:<br>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
<p>来自 <a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&amp;tqId=11194&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&amp;tqId=11194&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">FindContinuousSequence</span><span class="params">(<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> curSum = left + right;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= sum/<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curSum==sum)</span><br><span class="line">            &#123;</span><br><span class="line">                help(res, left, right);</span><br><span class="line">                right++;</span><br><span class="line">                curSum += right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curSum&gt;sum)</span><br><span class="line">            &#123;</span><br><span class="line">                curSum -= left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curSum&lt;sum)</span><br><span class="line">            &#123;</span><br><span class="line">                right++;</span><br><span class="line">                curSum += right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;=right; i++)</span><br><span class="line">            tmp.push_back(i);</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="10-和为S的两个数字"><a href="#10-和为S的两个数字" class="headerlink" title="10. 和为S的两个数字"></a>10. 和为S的两个数字</h3><p>题目描述:<br>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<p>输出描述:<br>对应每个测试案例，输出两个数，小的先输出。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&amp;tqId=11195&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&amp;tqId=11195&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="built_in">array</span>.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            curSum = <span class="built_in">array</span>[left] + <span class="built_in">array</span>[right];</span><br><span class="line">            <span class="keyword">if</span>(curSum == sum)</span><br><span class="line">            &#123;</span><br><span class="line">               res.push_back(<span class="built_in">array</span>[left]);</span><br><span class="line">               res.push_back(<span class="built_in">array</span>[right]);  <span class="comment">//距离最远的两个数乘积最小</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curSum &gt; sum)</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curSum &lt; sum)</span><br><span class="line">                left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>证明距离越远的两个数乘积越小：</strong><br>假如 $x+y=c, c$是常数，并且假设$y\geq x, y-x=d,$即证明$d$越大，$x\times y$越小。<br>由以上知，$y=x+d$, 因此，$2x+d=c$,可得$x=\frac{c−d}{2}$, $y=x+d=\frac{c+d}{2}$。<br>$x\times y=\frac{c^2−d^2}{4}$, 所以，d越大，乘积越小.</p>
</blockquote>
<h3 id="11-左旋转字符串"><a href="#11-左旋转字符串" class="headerlink" title="11. 左旋转字符串"></a>11. 左旋转字符串</h3><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<p>来自 <a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&amp;tqId=11196&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&amp;tqId=11196&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        str += str;</span><br><span class="line">        n = n%len;</span><br><span class="line">        <span class="keyword">return</span> str.substr(n, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>附加：</strong> 翻转单词顺序，输入字符串”I am a student.”，输出”student. a am I”</p>
<p>解决办法：2次翻转。第一次翻转为”.tneduts a ma I”, 然后翻转每个单词。代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Class Solution&#123;</span><br><span class="line">Public:</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">reverseSentence</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">		<span class="built_in">string</span> revs = reverse(s);</span><br><span class="line">		<span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line">		<span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(revs)</span></span>;</span><br><span class="line">		<span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">		<span class="keyword">while</span>(getline(ss, <span class="keyword">word</span>, <span class="string">' '</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			res+=reverse(<span class="keyword">word</span>)+<span class="string">" "</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res.substr(<span class="number">0</span>, len); <span class="comment">//去掉最后的空格</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">reverse</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(left&lt;right)</span><br><span class="line">			swap(s[left++], s[right--]);</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="12-扑克牌顺序"><a href="#12-扑克牌顺序" class="headerlink" title="12. 扑克牌顺序"></a>12. 扑克牌顺序</h3><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大小王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&amp;tqId=11198&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&amp;tqId=11198&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*思想：</span></span><br><span class="line"><span class="comment"> 1.对数组排序</span></span><br><span class="line"><span class="comment"> 2.统计数组中0的个数count</span></span><br><span class="line"><span class="comment"> 3.计算相邻元素的差值diff</span></span><br><span class="line"><span class="comment"> 4.如果存在相邻元素不为0，并且相等的情况，直接返回false</span></span><br><span class="line"><span class="comment"> 5.如果count&gt;=diff，返回true，否则，返回false */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.empty()) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        sort(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numbers.<span class="built_in">size</span>()<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                diff += numbers[i+<span class="number">1</span>] - numbers[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count&gt;=diff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="13-孩子们的游戏（圈中最后剩下的数字）"><a href="#13-孩子们的游戏（圈中最后剩下的数字）" class="headerlink" title="13. 孩子们的游戏（圈中最后剩下的数字）"></a>13. 孩子们的游戏（圈中最后剩下的数字）</h3><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<p>来自 <a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*方法1：构造环形列表，依次删除第m个，当指针指向it.end()时，另其重新指向begin(); */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span> || m&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            nums.push_back(i);</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); <span class="comment">//注意，此处必须是list，因为list删除后，指针仍然指向这个值，而vector删除后，迭代器会自动往后加</span></span><br><span class="line">        <span class="keyword">while</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                it++;</span><br><span class="line">                <span class="keyword">if</span>(it==nums.<span class="built_in">end</span>())</span><br><span class="line">                    it=nums.<span class="built_in">begin</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator next = ++it;</span><br><span class="line">            <span class="keyword">if</span>(next == nums.<span class="built_in">end</span>())</span><br><span class="line">                next = nums.<span class="built_in">begin</span>();</span><br><span class="line">            --it;</span><br><span class="line">            nums.erase(it);</span><br><span class="line">            it = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>方法2：推导出公式，其中f(n,m)表示从n中删除一个数字后剩余的数字。</p>
<script type="math/tex; mode=display">
    f(n,m)=\left\{ \begin{array}{l}
    &0 &,if \quad n=1 \\
    &[f(n-1,m)+m]\%n &,if \quad n>1\\
    \end{array}\right.</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span> || m&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (LastRemaining_Solution(n<span class="number">-1</span>, m) + m)%n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="14-求1-2-3-…-n"><a href="#14-求1-2-3-…-n" class="headerlink" title="14. 求1+2+3+…+n"></a>14. 求1+2+3+…+n</h3><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&amp;tqId=11200&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&amp;tqId=11200&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = n;</span><br><span class="line">        (n&gt;<span class="number">0</span>) &amp;&amp; (res += Sum_Solution(n<span class="number">-1</span>));   <span class="comment">//逻辑与功能，如果前面为真，则计算后边，否则，后边不计算</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="15-不使用加减乘除做加法"><a href="#15-不使用加减乘除做加法" class="headerlink" title="15. 不使用加减乘除做加法"></a>15. 不使用加减乘除做加法</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*思路：</span></span><br><span class="line"><span class="comment">	1. 两个数异或：相当于每一位相加，而不考虑进位；</span></span><br><span class="line"><span class="comment">	2. 两个数相与，并左移一位：相当于求得进位；</span></span><br><span class="line"><span class="comment">	3. 将上述两步的结果相加</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	来自 &lt;https://www.nowcoder.com/questionTerminal/59ac416b4b944300b617d4f7f111b215&gt; */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = num1 ^ num2;</span><br><span class="line">            <span class="keyword">int</span> carry = (num1 &amp; num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            num1 = sum;</span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="16-把字符串转化为整数"><a href="#16-把字符串转化为整数" class="headerlink" title="16. 把字符串转化为整数"></a>16. 把字符串转化为整数</h3><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
<p>输入描述:<br>输入一个字符串,包括数字字母符号,可以为空</p>
<p>输出描述:<br>如果是合法的数值表达则返回该数字，否则返回0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flg = <span class="number">1</span>; <span class="comment">//标记是否为正负</span></span><br><span class="line">        <span class="keyword">int</span> beg = <span class="number">0</span>; <span class="comment">//判断索引是从0开始还是1开始</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flg = <span class="number">-1</span>;</span><br><span class="line">            beg = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'+'</span>)</span><br><span class="line">            beg = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=beg; i&lt;len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]&gt;=<span class="string">'0'</span> &amp;&amp; str[i]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                res = res * <span class="number">10</span> + str[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * flg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="17-寻找重复数字"><a href="#17-寻找重复数字" class="headerlink" title="17. 寻找重复数字"></a>17. 寻找重复数字</h3><p>题目描述<br>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1：使用map，缺点需开辟额外空间，时间复杂度O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *duplication = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[numbers[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(mp[numbers[i]]&gt;=<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        *duplication = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><strong>很好的思想，复习时一定查看</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法2：无需开辟新的空间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(length &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *duplication = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = numbers[i];   <span class="comment">//令索引等于第i个数字</span></span><br><span class="line">            <span class="keyword">if</span>(index &gt;= length)</span><br><span class="line">                index -= length;           <span class="comment">// 如果该索引大于length，则减length</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[index] &gt;= length)</span><br><span class="line">            &#123;</span><br><span class="line">                *duplication = index;   <span class="comment">//如果索引指向的值大于length，则该索引就是重复的那个数，因为前边肯定有相同的索引指向了这个元素，例如[2,3,1,0,2,5,3], 第一个索引2指向的值numbers[2] = 1,然后让其加上length，变为1+7=8。当下一个索引2指向该值时，该值&gt;=length,说明前面肯定存在2，故可以直接返回，而不需要开辟新的空间  </span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            numbers[index] += length;</span><br><span class="line">        &#125;</span><br><span class="line">        *duplication = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="18-构建乘积数组"><a href="#18-构建乘积数组" class="headerlink" title="18. 构建乘积数组"></a>18. 构建乘积数组</h3><p>题目描述:<br>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&amp;tqId=11204&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&amp;tqId=11204&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a> </p>
<p><img src="./images/构建乘积数组.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">方法<span class="number">1</span>：先计算下三角，再计算上三角，然后相乘</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">down</span><span class="params">(A.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up</span><span class="params">(A.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;A.<span class="built_in">size</span>(); i++)</span><br><span class="line">            down[i] = down[i<span class="number">-1</span>] * A[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=A.<span class="built_in">size</span>()<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            up[i] = up[i+<span class="number">1</span>] * A[i+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res(A.<span class="built_in">size</span>(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.<span class="built_in">size</span>(); i++)</span><br><span class="line">            res[i] = down[i] * up[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法2：节省开辟空间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">down</span><span class="params">(A.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;A.<span class="built_in">size</span>(); i++)</span><br><span class="line">            down[i] = down[i<span class="number">-1</span>] * A[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=A.<span class="built_in">size</span>()<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = tmp * A[i+<span class="number">1</span>];</span><br><span class="line">            down[i] = tmp * down[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> down;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="19-正则表达式的匹配"><a href="#19-正则表达式的匹配" class="headerlink" title="19. 正则表达式的匹配"></a>19. 正则表达式的匹配</h3><p>题目描述<br>请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<p>来自 <a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&amp;tqId=11205&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&amp;tqId=11205&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    解这题需要把题意仔细研究清楚，反正我试了好多次才明白的。</span></span><br><span class="line"><span class="comment">    首先，考虑特殊情况：</span></span><br><span class="line"><span class="comment">         1&gt;两个字符串都为空，返回true</span></span><br><span class="line"><span class="comment">         2&gt;当第一个字符串不空，而第二个字符串空了，返回false（因为这样，就无法</span></span><br><span class="line"><span class="comment">            匹配成功了,而如果第一个字符串空了，第二个字符串非空，还是可能匹配成</span></span><br><span class="line"><span class="comment">            功的，比如第二个字符串是“a*a*a*a*”,由于‘*’之前的元素可以出现0次，</span></span><br><span class="line"><span class="comment">            所以有可能匹配成功）</span></span><br><span class="line"><span class="comment">    之后就开始匹配第一个字符，这里有两种可能：匹配成功或匹配失败。但考虑到pattern</span></span><br><span class="line"><span class="comment">    下一个字符可能是‘*’， 这里我们分两种情况讨论：pattern下一个字符为‘*’或</span></span><br><span class="line"><span class="comment">    不为‘*’：</span></span><br><span class="line"><span class="comment">          1&gt;pattern下一个字符不为‘*’：这种情况比较简单，直接匹配当前字符。如果</span></span><br><span class="line"><span class="comment">            匹配成功，继续匹配下一个；如果匹配失败，直接返回false。注意这里的</span></span><br><span class="line"><span class="comment">            “匹配成功”，除了两个字符相同的情况外，还有一种情况，就是pattern的</span></span><br><span class="line"><span class="comment">            当前字符为‘.’,同时str的当前字符不为‘\0’。</span></span><br><span class="line"><span class="comment">          2&gt;pattern下一个字符为‘*’时，稍微复杂一些，因为‘*’可以代表0个或多个。</span></span><br><span class="line"><span class="comment">            这里把这些情况都考虑到：</span></span><br><span class="line"><span class="comment">               a&gt;当‘*’匹配0个字符时，str当前字符不变，pattern当前字符后移两位，</span></span><br><span class="line"><span class="comment">                跳过这个‘*’符号；</span></span><br><span class="line"><span class="comment">               b&gt;当‘*’匹配1个或多个时，str当前字符移向下一个，pattern当前字符</span></span><br><span class="line"><span class="comment">                不变。（这里匹配1个或多个可以看成一种情况，因为：当匹配一个时，</span></span><br><span class="line"><span class="comment">                由于str移到了下一个字符，而pattern字符不变，就回到了上边的情况a；</span></span><br><span class="line"><span class="comment">                当匹配多于一个字符时，相当于从str的下一个字符继续开始匹配）</span></span><br><span class="line"><span class="comment">    之后再写代码就很简单了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如果pattern的下一个不等于‘*’</span></span><br><span class="line">        <span class="keyword">if</span>(*(pattern+<span class="number">1</span>) != <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*str == *pattern || (*str!=<span class="string">'\0'</span> &amp;&amp; *pattern==<span class="string">'.'</span>))</span><br><span class="line">                <span class="keyword">return</span> match(str+<span class="number">1</span>, pattern+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">// if(*(pattern+1) == '*')//如果pattern的下一个等于‘*’</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*str == *pattern || (*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'.'</span>))</span><br><span class="line">                <span class="keyword">return</span> match(str+<span class="number">1</span>, pattern) || match(str, pattern+<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> match(str, pattern+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="20-链表中环的入口节点"><a href="#20-链表中环的入口节点" class="headerlink" title="20. 链表中环的入口节点"></a>20. 链表中环的入口节点</h3><p>题目描述<br>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;tqId=11208&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;tqId=11208&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        采用快慢指针的方法，另快指针一次移动两个，慢指针一次移动一个。</span></span><br><span class="line"><span class="comment">        如果两者能够相遇说明存在环。否则，当fast为NULL时,代表不存在环。</span></span><br><span class="line"><span class="comment">        当两者相遇后，慢指针不动，另快指针指向链表头，并且每次快慢指针都</span></span><br><span class="line"><span class="comment">        只移动一次，当两者再次相遇时，指向的就是环的入口结点。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(!pHead || !(pHead-&gt;next)|| !(pHead-&gt;next-&gt;next))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* slow = pHead-&gt;next;</span><br><span class="line">        ListNode* fast = pHead-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast-&gt;next-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法2： 使用哈希表，需开辟O(n)空间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;ListNode*, <span class="keyword">int</span>&gt;mp;</span><br><span class="line">        ListNode* ptr = pHead;</span><br><span class="line">        <span class="keyword">while</span>(ptr!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[ptr]++;</span><br><span class="line">            <span class="keyword">if</span>(mp[ptr]&gt;=<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            ptr=ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*来自 &lt;https://www.nowcoder.com/profile/490351159/codeBookDetail?submissionId=35500459&gt; */</span></span><br></pre></td></tr></table></figure>
<h3 id="21-Longest-Common-Sequence-最长公共子序列-多次遇见"><a href="#21-Longest-Common-Sequence-最长公共子序列-多次遇见" class="headerlink" title="21. Longest Common Sequence(最长公共子序列)(多次遇见)"></a>21. Longest Common Sequence(最长公共子序列)(多次遇见)</h3><p>给定两个字符串，求解这两个字符串的最长公共子序列（不要求连续）。比如：s1 = BDCABA，s2 = ABCBDAB<br>则这两个字符串的最长公共子序列长度为4，最长公共子序列为：BCBA（任意一个就行）</p>
<p>求解方式：<br>这是一个动态规划的题目。对于可用动态规划求解的问题，一般有两个特征：①最优子结构；②重叠子问题</p>
<p><strong>①最优子结构:</strong></p>
<p>设 $X=(x_1,x_2,…..x_n)$ 和 $Y={y_1,y_2,…..y_m}$ 是两个序列，将 X和Y的最长公共子序列记为$LCS(X,Y)$<br>找出$LCS(X,Y)$就是一个最优化问题。因为，我们需要找到X 和 Y中最长的那个公共子序列。而要找X 和 Y的LCS，首先考虑X的最后一个元素和Y的最后一个元素。</p>
<ul>
<li>如果 $x<em>n=y_m$，即X的最后一个元素与Y的最后一个元素相同，这说明该元素一定位于公共子序列中。因此，现在只需要找：$LCS(X</em>{n-1}，Y<em>{m-1})$。$LCS(X</em>{n-1}，Y<em>{m-1})$就是原问题的一个子问题。为什么叫子问题？因为它的规模比原问题小。（小一个元素也是小嘛….）<br>为什么是最优的子问题？因为我们要找的是$X</em>{n-1}$ 和 $Y_{m-1}$ 的最长公共子序列啊。。。最长的！！！换句话说，就是最优的那个。（这里的最优就是最长的意思）</li>
<li><p>如果$x<em>n \neq y_m$，这下要麻烦一点，因为它产生了两个子问题：$LCS(X</em>{n-1}，Y<em>m)$和$LCS(X_n，Y</em>{m-1})$.<br>因为序列X 和 序列Y 的最后一个元素不相等嘛，那说明最后一个元素不可能是最长公共子序列中的元素嘛。（都不相等了，怎么公共嘛）。</p>
<ul>
<li><p>$LCS(X<em>{n-1}，Y_m)$表示：最长公共序列可以在$(x_1,x_2,….x</em>{n-1})$和 (y_1,y_2,…,y_n)中找。</p>
</li>
<li><p>$LCS(X<em>n,Y</em>{m-1})$表示：最长公共序列可以在$(x<em>1,x_2,…,x_n)$和$(y_1,y_2,…,y</em>{n-1})$中找。</p>
</li>
</ul>
</li>
</ul>
<p>求解上面两个子问题，得到的公共子序列谁最长，那谁就是 $LCS(X,Y)$。用数学表示就是：<br>$LCS=\max{LCS(X<em>{n-1}，Y_m),LCS(X_n，Y</em>{m-1})}$.<br>由于上述两个条件考虑到了所有可能的情况。因此，我们成功地把原问题 转化 成了 三个规模更小的子问题。</p>
<p><strong>②重叠子问题：</strong></p>
<p>重叠子问题是啥？就是说原问题 转化 成子问题后，  子问题中有相同的问题。咦？我怎么没有发现上面的三个子问题中有相同的啊？？？？<br>OK，来看看，原问题是：$LCS(X,Y)$。子问题有 ❶$LCS(X<em>{n-1},Y</em>{m-1})$    ❷$LCS(X<em>{n-1},Y_m)$  ❸$LCS(X_n,Y</em>{m-1})$<br>初一看，这三个子问题是不重叠的。可本质上它们是重叠的，因为它们只重叠了一大部分。举例：<br>第二个子问题：$LCS(X<em>{n-1},Y_m)$ 就包含了：问题❶$LCS(X</em>{n-1},Y<em>{m-1})$，为什么？<br>因为，当$X</em>{n-1}$ 和 $Y<em>m$ 的最后一个元素不相同时，我们又需要将$LCS(X</em>{n-1}，Y<em>m)$进行分解：分解成：$LCS(X</em>{n-1},Y<em>{m-1})$ 和 $LCS(X</em>{n-2},Y_m)$.</p>
<p>也就是说：在子问题的继续分解中，有些问题是重叠的。<br><img src="./images/最优子结构.png" alt><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> res=<span class="string">""</span>;</span><br><span class="line">	<span class="keyword">int</span> len1 = s1.<span class="built_in">size</span>(), len2 = s2.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;nums(len1+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len1; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=len2; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				nums[i][j] = nums[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(nums[i][j<span class="number">-1</span>]&gt;nums[i<span class="number">-1</span>][j])</span><br><span class="line">				nums[i][j] = nums[i][j<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				nums[i][j] = nums[i<span class="number">-1</span>][j];</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此时，nums[len1][len2]中保存的就是最长公共子序列的长度，要想得到任意最长公共子序列的字符串，则需继续进行以下步骤;</span></span><br><span class="line">	<span class="keyword">int</span> k = len1;</span><br><span class="line">	<span class="keyword">int</span> j = len2;</span><br><span class="line">	<span class="keyword">while</span> (k &gt;=<span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	      <span class="keyword">if</span> (s1[k] == s2[j]) </span><br><span class="line">	      &#123;  </span><br><span class="line">		res+=s1[k];</span><br><span class="line">		k--;</span><br><span class="line">	            j--;</span><br><span class="line">	      &#125;</span><br><span class="line">	     <span class="keyword">else</span> </span><br><span class="line">	     &#123;</span><br><span class="line">	            <span class="keyword">if</span> (nums[k][j - <span class="number">1</span>] &gt; nums[k - <span class="number">1</span>][j]) </span><br><span class="line">	                j--;  </span><br><span class="line">	            <span class="keyword">else</span> </span><br><span class="line">	                k--;</span><br><span class="line">	      &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="22-删除链表中的重复节点"><a href="#22-删除链表中的重复节点" class="headerlink" title="22. 删除链表中的重复节点"></a>22. 删除链表中的重复节点</h3><p>题目描述<br>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead || !(pHead-&gt;next))</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        ListNode* cur;</span><br><span class="line">        <span class="keyword">if</span>(pHead-&gt;val == pHead-&gt;next-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = pHead-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(cur &amp;&amp; cur-&gt;val == pHead-&gt;val)</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplication(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pHead-&gt;next = deleteDuplication(pHead-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="23-镜像二叉树"><a href="#23-镜像二叉树" class="headerlink" title="23. 镜像二叉树"></a>23. 镜像二叉树</h3><p>题目描述<br>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&amp;tqId=11211&amp;rp=3&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;tPage=3" target="_blank" rel="noopener">https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&amp;tqId=11211&amp;rp=3&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&amp;tPage=3</a> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetrical(TreeNode* pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        return help(pRoot, pRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    bool help(TreeNode* root1, TreeNode* root2)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!root1 &amp;&amp; !root2)</span><br><span class="line">            return true;</span><br><span class="line">        if(!root1 || !root2)</span><br><span class="line">            return false;</span><br><span class="line">        if(root1-&gt;val !&#x3D; root2-&gt;val)</span><br><span class="line">            return false;</span><br><span class="line">        return help(root1-&gt;left, root2-&gt;right) &amp;&amp; help(root1-&gt;right, root2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="24-按之字形顺序打印二叉树"><a href="#24-按之字形顺序打印二叉树" class="headerlink" title="24. 按之字形顺序打印二叉树"></a>24. 按之字形顺序打印二叉树</h3><p>题目描述<br>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<p>来自 <a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&amp;tqId=11212&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&amp;tqId=11212&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    struct TreeNode *left;</span><br><span class="line">    struct TreeNode *right;</span><br><span class="line">    TreeNode(int x) :</span><br><span class="line">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        if(!pRoot) return res;</span><br><span class="line">        stack&lt;TreeNode*&gt; s1; &#x2F;&#x2F;s1 入栈顺序先右后左</span><br><span class="line">        s1.push(pRoot);</span><br><span class="line">        stack&lt;TreeNode*&gt; s2; &#x2F;&#x2F;s2 入栈顺序先左后右</span><br><span class="line">        while(!s1.empty() || !s2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt;tmp;</span><br><span class="line">            int len;</span><br><span class="line">            if(s1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                len &#x3D; s2.size();</span><br><span class="line">                for(int i&#x3D;0; i&lt;len; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* top &#x3D; s2.top();</span><br><span class="line">                    s2.pop();</span><br><span class="line">                    tmp.push_back(top-&gt;val);</span><br><span class="line">                    if(top-&gt;right) s1.push(top-&gt;right);</span><br><span class="line">                    if(top-&gt;left) s1.push(top-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                len &#x3D; s1.size();</span><br><span class="line">                for(int i&#x3D;0; i&lt;len; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* t &#x3D; s1.top();</span><br><span class="line">                    s1.pop();</span><br><span class="line">                    tmp.push_back(t-&gt;val);</span><br><span class="line">                    if(t-&gt;left) s2.push(t-&gt;left);</span><br><span class="line">                    if(t-&gt;right) s2.push(t-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="25-动态规划解决找零钱问题-作业帮面试题"><a href="#25-动态规划解决找零钱问题-作业帮面试题" class="headerlink" title="25. 动态规划解决找零钱问题(作业帮面试题)"></a>25. 动态规划解决找零钱问题(作业帮面试题)</h3><p>在现实生活中，经常遇到找零问题，假设有数目不限的面值为1元，2元，5元，10元等等的硬币。给出需要找零金额，求出找零方案，要求：使用的硬币数目最少。</p>
<p>来自 <a href="https://blog.csdn.net/niaonao/article/details/78249256" target="_blank" rel="noopener">https://blog.csdn.net/niaonao/article/details/78249256</a> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_coins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> money)</span>  	<span class="comment">//讲解：nums中是现有的金钱面值，money是要找的零钱。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(money&lt;=<span class="number">0</span> || nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">coins</span><span class="params">(money+<span class="number">1</span>, <span class="number">0</span>)</span></span>;  	<span class="comment">//存放的是对于每一个面值需要的最少张数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=money; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mincoin = i;			<span class="comment">//指当全部使用1元时需要的张数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[j] &lt;= i)</span><br><span class="line">				mincoin = <span class="built_in">min</span>(mincoin, coins[i - nums[j]] + <span class="number">1</span>); 	<span class="comment">//选择使用较少的张数，并存于coins数组中</span></span><br><span class="line">		&#125;</span><br><span class="line">		coins[i] = mincoin;	<span class="comment">//更新零钱为i时需要的最小的张数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> coins[money];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-旋转数组的最小数字"><a href="#26-旋转数组的最小数字" class="headerlink" title="26. 旋转数组的最小数字"></a>26. 旋转数组的最小数字</h3><p>题目描述:<br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>链接：<a href="https://www.nowcoder.com/questionTerminal/9f3231a991af4f55b95579b44b7a01ba" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/9f3231a991af4f55b95579b44b7a01ba</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*采用二分法解答这个问题，  </span></span><br><span class="line"><span class="comment">mid = low + (high - low)/2 </span></span><br><span class="line"><span class="comment">需要考虑三种情况： </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(1) array[mid] &gt; array[high]: </span></span><br><span class="line"><span class="comment">出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。 </span></span><br><span class="line"><span class="comment">low = mid + 1 </span></span><br><span class="line"><span class="comment">(2) array[mid] == array[high]: </span></span><br><span class="line"><span class="comment">出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边 </span></span><br><span class="line"><span class="comment">还是右边,这时只好一个一个试 ， </span></span><br><span class="line"><span class="comment">high = high - 1 </span></span><br><span class="line"><span class="comment">(3) array[mid] &lt; array[high]: </span></span><br><span class="line"><span class="comment">出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左 </span></span><br><span class="line"><span class="comment">边。因为右边必然都是递增的。 </span></span><br><span class="line"><span class="comment">high = mid </span></span><br><span class="line"><span class="comment">注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字 </span></span><br><span class="line"><span class="comment">比如 array = [4,6] </span></span><br><span class="line"><span class="comment">array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ; </span></span><br><span class="line"><span class="comment">如果high = mid - 1，就会产生错误， 因此high = mid </span></span><br><span class="line"><span class="comment">但情形(1)中low = mid + 1就不会错误*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">每次都用中间的数跟最右边的比较，</span></span><br><span class="line"><span class="comment">1）如果mid大于右边则说明最小值在右边，left=mid+1</span></span><br><span class="line"><span class="comment">2）如果mid小于右边则说明最小值在mid或mid的左边，right = mid</span></span><br><span class="line"><span class="comment">3）如果mid等于右边，此时不好说明最小值在mid左边还是右边，只能顺序查找，right--</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rotateArray.<span class="built_in">size</span>()&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = rotateArray.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//if(rotateArray[left] &lt; rotateArray[right]) return rotateArray[left];</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt; rotateArray[right])</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] == rotateArray[right])</span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="27-重建二叉树（已知先序和后序）"><a href="#27-重建二叉树（已知先序和后序）" class="headerlink" title="27. 重建二叉树（已知先序和后序）"></a>27. 重建二叉树（已知先序和后序）</h3><p>题目描述:<br>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> help(pre, <span class="number">0</span>, pre.<span class="built_in">size</span>()<span class="number">-1</span>, vin, <span class="number">0</span>, vin.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">help</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vin, <span class="keyword">int</span> il, <span class="keyword">int</span> ir)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl&gt;pr || il&gt;ir) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* pHead = <span class="keyword">new</span> TreeNode(pre[pl]);</span><br><span class="line">        TreeNode* ptr = pHead;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=il; i&lt;=ir; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vin[i] == pre[pl])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pl1 = pl + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pr1 = i - il + pl;</span><br><span class="line">        <span class="keyword">int</span> il1 = il;</span><br><span class="line">        <span class="keyword">int</span> ir1 = i - <span class="number">1</span>;</span><br><span class="line">        ptr-&gt;left = help(pre, pl1, pr1, vin, il1, ir1);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pl2 = pl + i - il + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pr2 = pr;</span><br><span class="line">        <span class="keyword">int</span> il2 = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ir2 = ir;</span><br><span class="line">        ptr-&gt;right = help(pre, pl2, pr2, vin, il2, ir2);</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="28-调整数组顺序使奇数位于偶数前面"><a href="#28-调整数组顺序使奇数位于偶数前面" class="headerlink" title="28. 调整数组顺序使奇数位于偶数前面"></a>28. 调整数组顺序使奇数位于偶数前面</h3><p>题目描述:<br>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.要想保证原有次序，则只能顺次移动或相邻交换。</span></span><br><span class="line"><span class="comment"> * 2.i从左向右遍历，找到第一个偶数。</span></span><br><span class="line"><span class="comment"> * 3.j从i+1开始向后找，直到找到第一个奇数。</span></span><br><span class="line"><span class="comment"> * 4.将[i,...,j-1]的元素整体后移一位，最后将找到的奇数放入i位置，然后i++。</span></span><br><span class="line"><span class="comment"> * 5.終止條件：j向後遍歷查找失敗。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">array</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;len &amp;&amp; !isEven(<span class="built_in">array</span>[i]))</span><br><span class="line">                i++;</span><br><span class="line">            j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;len &amp;&amp; isEven(<span class="built_in">array</span>[j]))</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;len)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="built_in">array</span>[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j; k&gt;i; k--)</span><br><span class="line">                    <span class="built_in">array</span>[k] = <span class="built_in">array</span>[k<span class="number">-1</span>];</span><br><span class="line">                <span class="built_in">array</span>[i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="29-二叉树遍历的递归与非递归（前序、中序、后序）"><a href="#29-二叉树遍历的递归与非递归（前序、中序、后序）" class="headerlink" title="29.二叉树遍历的递归与非递归（前序、中序、后序）"></a>29.二叉树遍历的递归与非递归（前序、中序、后序）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.递归实现前序遍历*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder1</span><span class="params">(BinTree *root)</span>     <span class="comment">//递归前序遍历 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        preOrder1(root-&gt;lchild);</span><br><span class="line">        preOrder1(root-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*2.非递归实现前序遍历</span></span><br><span class="line"><span class="comment">对于任一结点P：</span></span><br><span class="line"><span class="comment">     1)访问结点P，并将结点P入栈;</span></span><br><span class="line"><span class="comment">     2)判断结点P的左孩子是否为空，若为空，则取栈顶结点并进行出栈操作，并将栈顶结点的右孩子置为当前的结点P，循环至1);若不为空，则将P的左孩子置为当前的结点P;</span></span><br><span class="line"><span class="comment">     3)直到P为NULL并且栈为空，则遍历结束。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder2</span><span class="params">(BinTree *root)</span>     <span class="comment">//非递归前序遍历 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinTree*&gt; s;</span><br><span class="line">    BinTree *p=root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            p=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.递归实现中序遍历*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder1</span><span class="params">(BinTree *root)</span>      <span class="comment">//递归中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inOrder1(root-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        inOrder1(root-&gt;rchild);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.非递归实现中序遍历*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder2</span><span class="params">(BinTree *root)</span>      <span class="comment">//非递归中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinTree*&gt; s;</span><br><span class="line">    BinTree *p=root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            p=s.top();</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.后序遍历的递归实现*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder1</span><span class="params">(BinTree *root)</span>    <span class="comment">//递归后序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postOrder1(root-&gt;lchild);</span><br><span class="line">        postOrder1(root-&gt;rchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.后序遍历的非递归实现</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存 在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了 每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder3</span><span class="params">(BinTree *root)</span>     <span class="comment">//非递归后序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinTree*&gt; s;</span><br><span class="line">    BinTree *cur;                      <span class="comment">//当前结点 </span></span><br><span class="line">    BinTree *pre=<span class="literal">NULL</span>;                 <span class="comment">//前一次访问的结点 </span></span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        cur=s.top();</span><br><span class="line">        <span class="keyword">if</span>((cur-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;cur-&gt;rchild==<span class="literal">NULL</span>)||</span><br><span class="line">           (pre!=<span class="literal">NULL</span>&amp;&amp;(pre==cur-&gt;lchild||pre==cur-&gt;rchild)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;cur-&gt;data&lt;&lt;<span class="string">" "</span>;  <span class="comment">//如果当前结点没有孩子结点或者孩子节点都已被访问过 </span></span><br><span class="line">              s.pop();</span><br><span class="line">            pre=cur; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">                s.push(cur-&gt;rchild);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;lchild!=<span class="literal">NULL</span>)    </span><br><span class="line">                s.push(cur-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="30-数组中只出现一次的数字"><a href="#30-数组中只出现一次的数字" class="headerlink" title="30. 数组中只出现一次的数字"></a>30. 数组中只出现一次的数字</h3><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data,<span class="keyword">int</span>* num1,<span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = data.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = data[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)</span><br><span class="line">            tmp ^= data[i];</span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((tmp&amp;<span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = tmp&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        *num1=<span class="number">0</span>, *num2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(isBit(data[i], index))</span><br><span class="line">                *num1 ^= data[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *num2 ^= data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n=n&gt;&gt;index;</span><br><span class="line">        <span class="keyword">return</span> (n&amp;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="31-二叉搜索树的第k个节点"><a href="#31-二叉搜索树的第k个节点" class="headerlink" title="31.二叉搜索树的第k个节点"></a>31.二叉搜索树的第k个节点</h3><p>题目描述:<br>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt;s;</span><br><span class="line">        TreeNode* p = pRoot;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p || !s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(p)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(p);</span><br><span class="line">                p=p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                p = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">if</span>(index==k)</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* node = KthNode(pRoot-&gt;left, k);</span><br><span class="line">        <span class="keyword">if</span>(node) <span class="keyword">return</span> node;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count==k) <span class="keyword">return</span> pRoot;</span><br><span class="line">        node = KthNode(pRoot-&gt;right, k);</span><br><span class="line">        <span class="keyword">if</span>(node) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="32-二叉搜索树与双向链表"><a href="#32-二叉搜索树与双向链表" class="headerlink" title="32. 二叉搜索树与双向链表"></a>32. 二叉搜索树与双向链表</h3><p>题目描述<br>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* root = pRootOfTree;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() || pRootOfTree)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(pRootOfTree)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(pRootOfTree);</span><br><span class="line">                pRootOfTree = pRootOfTree-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                pRootOfTree = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span>(!pre)</span><br><span class="line">                &#123;</span><br><span class="line">                    root = pRootOfTree;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    pre-&gt;right = pRootOfTree;</span><br><span class="line">                    pRootOfTree-&gt;left = pre;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = pRootOfTree;</span><br><span class="line">                pRootOfTree = pRootOfTree-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="33-快速排序："><a href="#33-快速排序：" class="headerlink" title="33. 快速排序："></a>33. 快速排序：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> piv = nums[left];</span><br><span class="line">    <span class="keyword">int</span> low = left, high = right;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; piv&lt;=nums[high])</span><br><span class="line">            high--;</span><br><span class="line">        nums[low] = nums[high];</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; piv&gt;=nums[low])</span><br><span class="line">            low++;</span><br><span class="line">        nums[high] = nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[low] = piv;</span><br><span class="line">    qsort(nums, left, low<span class="number">-1</span>);</span><br><span class="line">    qsort(nums, low+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">chennan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chennan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  











<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
